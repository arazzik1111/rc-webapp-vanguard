/*
 * WARNING THIS FILE IS AUTO-GENERATED DO NOT MODIFY YOUR CHANGES WILL BE OVERWRITTEN!
 */
import type { AdAccountGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/AdAccountGetResponseDto';
import type { AdAccountUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/AdAccountUpdateRequestDto';
import type { BoostAdCreativeDeleteResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdCreatives/BoostAdCreativeDeleteResponseDto';
import type { BoostAdCreativeGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdCreatives/BoostAdCreativeGetResponseDto';
import type { BoostAdCreativePostRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdCreatives/BoostAdCreativePostRequestDto';
import type { BoostAdCreativePostResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdCreatives/BoostAdCreativePostResponseDto';
import type { BoostAdCreativeRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdCreatives/BoostAdCreativeRequestDto';
import type { BoostAdCreativesGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdCreatives/BoostAdCreativesGetResponseDto';
import type { BoostAdPostRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/Ads/BoostAdPostRequestDto';
import type { BoostAdPostResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/Ads/BoostAdPostResponseDto';
import type { BoostAdRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/Ads/BoostAdRequestDto';
import type { BoostAdSetDeleteRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdSets/BoostAdSetDeleteRequestDto';
import type { BoostAdSetDeleteResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdSets/BoostAdSetDeleteResponseDto';
import type { BoostAdSetPostRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdSets/BoostAdSetPostRequestDto';
import type { BoostAdSetPostResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdSets/BoostAdSetPostResponseDto';
import type { BoostAdSetReachEstimateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdSets/BoostAdSetReachEstimateResponseDto';
import type { BoostAdSetUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdSets/BoostAdSetUpdateRequestDto';
import type { BoostAdSetUpdateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdSets/BoostAdSetUpdateResponseDto';
import type { BoostGeoLocationGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/AdSets/BoostGeoLocationGetResponseDto';
import type { BoostAudiencesGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/Audience/BoostAudiencesGetResponseDto';
import type { BoostAdAccountReachEstimateGetRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/BoostAdAccountReachEstimateGetRequestDto';
import type { BoostAdAccountReachEstimateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/BoostAdAccountReachEstimateResponseDto';
import type { BoostCampaignChangeStatusRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/BoostCampaignChangeStatusRequestDto';
import type { BoostCampaignDeleteResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/BoostCampaignDeleteResponseDto';
import type { BoostCampaignsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/BoostCampaignsGetResponseDto';
import type { BoostCampaignUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/BoostCampaignUpdateRequestDto';
import type { BoostCampaignUpdateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/BoostCampaignUpdateResponseDto';
import type { BoostInsightsGetRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/Insights/BoostInsightsGetRequestDto';
import type { BoostInsightsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/Boosts/Insights/BoostInsightsGetResponseDto';
import type { InstagramEligibilityGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/InstagramEligibilityGetResponseDto';
import type { MetaAdAccountGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/MetaAdAccountGetResponseDto';
import type { MetaAdAccountsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/MetaAdAccountsGetResponseDto';
import type { MetaAdAccountUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/MetaAdAccountUpdateRequestDto';
import type { MetaAdAccountUpdateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Dtos/MetaAdAccountUpdateResponseDto';
import type { ResponsiveSearchAdsGroupSuggestionsRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Google/ResponsiveSearchAds/Dtos/Groups/Suggestions/ResponsiveSearchAdsGroupSuggestionsRequestDto';
import type { ResponsiveSearchAdsGroupSuggestionsResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Google/ResponsiveSearchAds/Dtos/Groups/Suggestions/ResponsiveSearchAdsGroupSuggestionsResponseDto';
import type { ResponsiveSearchAdPostRequestDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Google/ResponsiveSearchAds/Dtos/ResponsiveSearchAdPostRequestDto';
import type { ResponsiveSearchAdResponseDto } from '@models/swagger/App/Presentation/Api/Client/Ads/Google/ResponsiveSearchAds/Dtos/ResponsiveSearchAdResponseDto';
import type { BadRequestException } from '@models/swagger/DDD/Infrastructure/Exceptions/BadRequestException';
import type { ForbiddenException } from '@models/swagger/DDD/Infrastructure/Exceptions/ForbiddenException';
import type { InternalErrorException } from '@models/swagger/DDD/Infrastructure/Exceptions/InternalErrorException';
import type { MethodNotAllowedException } from '@models/swagger/DDD/Infrastructure/Exceptions/MethodNotAllowedException';
import type { NotFoundException } from '@models/swagger/DDD/Infrastructure/Exceptions/NotFoundException';
import type { UnauthorizedException } from '@models/swagger/DDD/Infrastructure/Exceptions/UnauthorizedException';
import { createAsyncThunk } from '@reduxjs/toolkit';
import { firstValueFrom, Observable } from 'rxjs';

import { EndPoint } from '../../../api-config';
import { HttpStore } from '../../http.store';
import { AbortControllersManager } from '../../store-helpers/abort-controllers-manager';

export type GetClientAdsLocationsAdAccountByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `keywords`
   * - `boostCampaigns`
   *   - Allowed filter properties are:
   *     - `adAccountId`
   *     - `status`
   *     - `objective`
   *     - `externalId`
   *     - `name`
   *     - `createdExternally`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `adSets.bidAmount`
   *     - `adSets.dailyBudget`
   *     - `adSets.billingEvent`
   *     - `adSets.boostCampaignId`
   *     - `adSets.externalId`
   *     - `adSets.name`
   *     - `adSets.optimizationGoal`
   *     - `adSets.startTime`
   *     - `adSets.stopTime`
   *     - `adSets.status`
   *     - `adSets.destinationType`
   *     - `adSets.targeting.ageMin`
   *     - `adSets.targeting.ageMax`
   *     - `adSets.targeting.externalId`
   *     - `adSets.targeting.audienceType`
   *     - `adSets.targeting.facebookPositions`
   *     - `adSets.targeting.genders`
   *     - `adSets.id`
   *     - `adSets.created`
   *     - `adSets.updated`
   *   - Allowed orderBy properties are:
   *     - `adAccountId`
   *     - `status`
   *     - `objective`
   *     - `externalId`
   *     - `name`
   *     - `createdExternally`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `adSets.bidAmount`
   *     - `adSets.dailyBudget`
   *     - `adSets.billingEvent`
   *     - `adSets.boostCampaignId`
   *     - `adSets.externalId`
   *     - `adSets.name`
   *     - `adSets.optimizationGoal`
   *     - `adSets.startTime`
   *     - `adSets.stopTime`
   *     - `adSets.status`
   *     - `adSets.destinationType`
   *     - `adSets.targeting.ageMin`
   *     - `adSets.targeting.ageMax`
   *     - `adSets.targeting.externalId`
   *     - `adSets.targeting.audienceType`
   *     - `adSets.targeting.facebookPositions`
   *     - `adSets.targeting.genders`
   *     - `adSets.id`
   *     - `adSets.created`
   *     - `adSets.updated`
   * - `facebookConnection`</details>
   */
  expand?: string;
};
export type PatchClientAdsLocationsAdAccountUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `keywords`
   * - `boostCampaigns`
   *   - Allowed filter properties are:
   *     - `adAccountId`
   *     - `status`
   *     - `objective`
   *     - `externalId`
   *     - `name`
   *     - `createdExternally`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `adSets.bidAmount`
   *     - `adSets.dailyBudget`
   *     - `adSets.billingEvent`
   *     - `adSets.boostCampaignId`
   *     - `adSets.externalId`
   *     - `adSets.name`
   *     - `adSets.optimizationGoal`
   *     - `adSets.startTime`
   *     - `adSets.stopTime`
   *     - `adSets.status`
   *     - `adSets.destinationType`
   *     - `adSets.targeting.ageMin`
   *     - `adSets.targeting.ageMax`
   *     - `adSets.targeting.externalId`
   *     - `adSets.targeting.audienceType`
   *     - `adSets.targeting.facebookPositions`
   *     - `adSets.targeting.genders`
   *     - `adSets.id`
   *     - `adSets.created`
   *     - `adSets.updated`
   *   - Allowed orderBy properties are:
   *     - `adAccountId`
   *     - `status`
   *     - `objective`
   *     - `externalId`
   *     - `name`
   *     - `createdExternally`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `adSets.bidAmount`
   *     - `adSets.dailyBudget`
   *     - `adSets.billingEvent`
   *     - `adSets.boostCampaignId`
   *     - `adSets.externalId`
   *     - `adSets.name`
   *     - `adSets.optimizationGoal`
   *     - `adSets.startTime`
   *     - `adSets.stopTime`
   *     - `adSets.status`
   *     - `adSets.destinationType`
   *     - `adSets.targeting.ageMin`
   *     - `adSets.targeting.ageMax`
   *     - `adSets.targeting.externalId`
   *     - `adSets.targeting.audienceType`
   *     - `adSets.targeting.facebookPositions`
   *     - `adSets.targeting.genders`
   *     - `adSets.id`
   *     - `adSets.created`
   *     - `adSets.updated`
   * - `facebookConnection`</details>
   */
  expand?: string;
};
export type PostClientAdsLocationsAdAccountUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `keywords`
   * - `boostCampaigns`
   *   - Allowed filter properties are:
   *     - `adAccountId`
   *     - `status`
   *     - `objective`
   *     - `externalId`
   *     - `name`
   *     - `createdExternally`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `adSets.bidAmount`
   *     - `adSets.dailyBudget`
   *     - `adSets.billingEvent`
   *     - `adSets.boostCampaignId`
   *     - `adSets.externalId`
   *     - `adSets.name`
   *     - `adSets.optimizationGoal`
   *     - `adSets.startTime`
   *     - `adSets.stopTime`
   *     - `adSets.status`
   *     - `adSets.destinationType`
   *     - `adSets.targeting.ageMin`
   *     - `adSets.targeting.ageMax`
   *     - `adSets.targeting.externalId`
   *     - `adSets.targeting.audienceType`
   *     - `adSets.targeting.facebookPositions`
   *     - `adSets.targeting.genders`
   *     - `adSets.id`
   *     - `adSets.created`
   *     - `adSets.updated`
   *   - Allowed orderBy properties are:
   *     - `adAccountId`
   *     - `status`
   *     - `objective`
   *     - `externalId`
   *     - `name`
   *     - `createdExternally`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `adSets.bidAmount`
   *     - `adSets.dailyBudget`
   *     - `adSets.billingEvent`
   *     - `adSets.boostCampaignId`
   *     - `adSets.externalId`
   *     - `adSets.name`
   *     - `adSets.optimizationGoal`
   *     - `adSets.startTime`
   *     - `adSets.stopTime`
   *     - `adSets.status`
   *     - `adSets.destinationType`
   *     - `adSets.targeting.ageMin`
   *     - `adSets.targeting.ageMax`
   *     - `adSets.targeting.externalId`
   *     - `adSets.targeting.audienceType`
   *     - `adSets.targeting.facebookPositions`
   *     - `adSets.targeting.genders`
   *     - `adSets.id`
   *     - `adSets.created`
   *     - `adSets.updated`
   * - `facebookConnection`</details>
   */
  expand?: string;
};
export type PostClientAdsLocationsAdAccountEstimateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
};
export type GetClientAdsLocationsAdAccountMetaAdAccountsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Whether to propose and save opening hours or not
   */
  proposeAndSaveOpeningHours?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type PatchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientAdsLocationsBoostAdUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `boostAdCreative`
   *   - Allowed filter properties are:
   *     - `objectStorySpec.instagramActorId`
   *     - `objectStorySpec.linkData.name`
   *     - `objectStorySpec.linkData.description`
   *     - `objectStorySpec.linkData.link`
   *     - `objectStorySpec.linkData.picture`
   *     - `objectStorySpec.linkData.message`
   *     - `objectStorySpec.linkData.childAttachments`
   *     - `objectStorySpec.linkData.callToAction.type`
   *     - `objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `objectStorySpec.linkData.callToAction.value.appLink`
   *     - `objectStorySpec.linkData.callToAction.value.application`
   *     - `objectStorySpec.linkData.callToAction.value.link`
   *     - `objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `objectStorySpec.linkData.callToAction.value.page`
   *     - `objectStorySpec.pageId`
   *     - `objectStorySpec.postExternalId`
   *     - `objectStorySpec.callToActionType`
   *     - `postId`
   *     - `name`
   *     - `externalId`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `post.type`
   *     - `post.status`
   *     - `post.createdExternally`
   *     - `post.content`
   *     - `post.locationId`
   *     - `post.scheduleAt`
   *     - `post.publishedAt`
   *     - `post.settings.google.languageCode`
   *     - `post.settings.google.callToAction.actionType`
   *     - `post.settings.google.callToAction.url`
   *     - `post.settings.google.error`
   *     - `post.settings.google.createdTime`
   *     - `post.settings.google.updatedTime`
   *     - `post.settings.google.externalId`
   *     - `post.settings.google.publishOnListingService`
   *     - `post.settings.google.status`
   *     - `post.settings.google.content`
   *     - `post.settings.google.permalinkUrl`
   *     - `post.settings.google.errorMessage`
   *     - `post.settings.google.publishedAt`
   *     - `post.settings.google.requireListingUpdate`
   *     - `post.settings.google.created`
   *     - `post.settings.google.updated`
   *     - `post.settings.facebook.views`
   *     - `post.settings.facebook.likes`
   *     - `post.settings.facebook.shares`
   *     - `post.settings.facebook.error`
   *     - `post.settings.facebook.createdTime`
   *     - `post.settings.facebook.updatedTime`
   *     - `post.settings.facebook.externalId`
   *     - `post.settings.facebook.publishOnListingService`
   *     - `post.settings.facebook.status`
   *     - `post.settings.facebook.content`
   *     - `post.settings.facebook.permalinkUrl`
   *     - `post.settings.facebook.errorMessage`
   *     - `post.settings.facebook.publishedAt`
   *     - `post.settings.facebook.requireListingUpdate`
   *     - `post.settings.instagram.error.type`
   *     - `post.settings.instagram.error.message`
   *     - `post.settings.instagram.error.code`
   *     - `post.settings.instagram.owner.id`
   *     - `post.settings.instagram.likes`
   *     - `post.settings.instagram.comments`
   *     - `post.settings.instagram.createdTime`
   *     - `post.settings.instagram.updatedTime`
   *     - `post.settings.instagram.externalId`
   *     - `post.settings.instagram.publishOnListingService`
   *     - `post.settings.instagram.status`
   *     - `post.settings.instagram.content`
   *     - `post.settings.instagram.permalinkUrl`
   *     - `post.settings.instagram.errorMessage`
   *     - `post.settings.instagram.publishedAt`
   *     - `post.settings.instagram.requireListingUpdate`
   *     - `post.settings.instagram.created`
   *     - `post.settings.instagram.updated`
   *     - `post.id`
   *     - `post.created`
   *     - `post.updated`
   *   - Allowed orderBy properties are:
   *     - `objectStorySpec.instagramActorId`
   *     - `objectStorySpec.linkData.name`
   *     - `objectStorySpec.linkData.description`
   *     - `objectStorySpec.linkData.link`
   *     - `objectStorySpec.linkData.picture`
   *     - `objectStorySpec.linkData.message`
   *     - `objectStorySpec.linkData.childAttachments`
   *     - `objectStorySpec.linkData.callToAction.type`
   *     - `objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `objectStorySpec.linkData.callToAction.value.appLink`
   *     - `objectStorySpec.linkData.callToAction.value.application`
   *     - `objectStorySpec.linkData.callToAction.value.link`
   *     - `objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `objectStorySpec.linkData.callToAction.value.page`
   *     - `objectStorySpec.pageId`
   *     - `objectStorySpec.postExternalId`
   *     - `objectStorySpec.callToActionType`
   *     - `postId`
   *     - `name`
   *     - `externalId`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `post.type`
   *     - `post.status`
   *     - `post.createdExternally`
   *     - `post.content`
   *     - `post.locationId`
   *     - `post.scheduleAt`
   *     - `post.publishedAt`
   *     - `post.settings.google.languageCode`
   *     - `post.settings.google.callToAction.actionType`
   *     - `post.settings.google.callToAction.url`
   *     - `post.settings.google.error`
   *     - `post.settings.google.createdTime`
   *     - `post.settings.google.updatedTime`
   *     - `post.settings.google.externalId`
   *     - `post.settings.google.publishOnListingService`
   *     - `post.settings.google.status`
   *     - `post.settings.google.content`
   *     - `post.settings.google.permalinkUrl`
   *     - `post.settings.google.errorMessage`
   *     - `post.settings.google.publishedAt`
   *     - `post.settings.google.requireListingUpdate`
   *     - `post.settings.google.created`
   *     - `post.settings.google.updated`
   *     - `post.settings.facebook.views`
   *     - `post.settings.facebook.likes`
   *     - `post.settings.facebook.shares`
   *     - `post.settings.facebook.error`
   *     - `post.settings.facebook.createdTime`
   *     - `post.settings.facebook.updatedTime`
   *     - `post.settings.facebook.externalId`
   *     - `post.settings.facebook.publishOnListingService`
   *     - `post.settings.facebook.status`
   *     - `post.settings.facebook.content`
   *     - `post.settings.facebook.permalinkUrl`
   *     - `post.settings.facebook.errorMessage`
   *     - `post.settings.facebook.publishedAt`
   *     - `post.settings.facebook.requireListingUpdate`
   *     - `post.settings.instagram.error.type`
   *     - `post.settings.instagram.error.message`
   *     - `post.settings.instagram.error.code`
   *     - `post.settings.instagram.owner.id`
   *     - `post.settings.instagram.likes`
   *     - `post.settings.instagram.comments`
   *     - `post.settings.instagram.createdTime`
   *     - `post.settings.instagram.updatedTime`
   *     - `post.settings.instagram.externalId`
   *     - `post.settings.instagram.publishOnListingService`
   *     - `post.settings.instagram.status`
   *     - `post.settings.instagram.content`
   *     - `post.settings.instagram.permalinkUrl`
   *     - `post.settings.instagram.errorMessage`
   *     - `post.settings.instagram.publishedAt`
   *     - `post.settings.instagram.requireListingUpdate`
   *     - `post.settings.instagram.created`
   *     - `post.settings.instagram.updated`
   *     - `post.id`
   *     - `post.created`
   *     - `post.updated`</details>
   */
  expand?: string;
};
export type DeleteClientAdsLocationsBoostAdDeleteByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientAdsLocationsBoostAdCreativeUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `objectStorySpec.instagramActorId`
   * - `objectStorySpec.linkData.name`
   * - `objectStorySpec.linkData.description`
   * - `objectStorySpec.linkData.link`
   * - `objectStorySpec.linkData.picture`
   * - `objectStorySpec.linkData.message`
   * - `objectStorySpec.linkData.childAttachments`
   * - `objectStorySpec.linkData.callToAction.type`
   * - `objectStorySpec.linkData.callToAction.value.appDestination`
   * - `objectStorySpec.linkData.callToAction.value.appLink`
   * - `objectStorySpec.linkData.callToAction.value.application`
   * - `objectStorySpec.linkData.callToAction.value.link`
   * - `objectStorySpec.linkData.callToAction.value.linkCaption`
   * - `objectStorySpec.linkData.callToAction.value.page`
   * - `objectStorySpec.pageId`
   * - `objectStorySpec.postExternalId`
   * - `objectStorySpec.callToActionType`
   * - `postId`
   * - `name`
   * - `externalId`
   * - `id`
   * - `created`
   * - `updated`
   * - `post.type`
   * - `post.status`
   * - `post.createdExternally`
   * - `post.content`
   * - `post.locationId`
   * - `post.scheduleAt`
   * - `post.publishedAt`
   * - `post.settings.google.languageCode`
   * - `post.settings.google.callToAction.actionType`
   * - `post.settings.google.callToAction.url`
   * - `post.settings.google.error`
   * - `post.settings.google.createdTime`
   * - `post.settings.google.updatedTime`
   * - `post.settings.google.externalId`
   * - `post.settings.google.publishOnListingService`
   * - `post.settings.google.status`
   * - `post.settings.google.content`
   * - `post.settings.google.permalinkUrl`
   * - `post.settings.google.errorMessage`
   * - `post.settings.google.publishedAt`
   * - `post.settings.google.requireListingUpdate`
   * - `post.settings.google.created`
   * - `post.settings.google.updated`
   * - `post.settings.facebook.views`
   * - `post.settings.facebook.likes`
   * - `post.settings.facebook.shares`
   * - `post.settings.facebook.error`
   * - `post.settings.facebook.createdTime`
   * - `post.settings.facebook.updatedTime`
   * - `post.settings.facebook.externalId`
   * - `post.settings.facebook.publishOnListingService`
   * - `post.settings.facebook.status`
   * - `post.settings.facebook.content`
   * - `post.settings.facebook.permalinkUrl`
   * - `post.settings.facebook.errorMessage`
   * - `post.settings.facebook.publishedAt`
   * - `post.settings.facebook.requireListingUpdate`
   * - `post.settings.instagram.error.type`
   * - `post.settings.instagram.error.message`
   * - `post.settings.instagram.error.code`
   * - `post.settings.instagram.owner.id`
   * - `post.settings.instagram.likes`
   * - `post.settings.instagram.comments`
   * - `post.settings.instagram.createdTime`
   * - `post.settings.instagram.updatedTime`
   * - `post.settings.instagram.externalId`
   * - `post.settings.instagram.publishOnListingService`
   * - `post.settings.instagram.status`
   * - `post.settings.instagram.content`
   * - `post.settings.instagram.permalinkUrl`
   * - `post.settings.instagram.errorMessage`
   * - `post.settings.instagram.publishedAt`
   * - `post.settings.instagram.requireListingUpdate`
   * - `post.settings.instagram.created`
   * - `post.settings.instagram.updated`
   * - `post.id`
   * - `post.created`
   * - `post.updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `objectStorySpec.instagramActorId`
   * - `objectStorySpec.linkData.name`
   * - `objectStorySpec.linkData.description`
   * - `objectStorySpec.linkData.link`
   * - `objectStorySpec.linkData.picture`
   * - `objectStorySpec.linkData.message`
   * - `objectStorySpec.linkData.childAttachments`
   * - `objectStorySpec.linkData.callToAction.type`
   * - `objectStorySpec.linkData.callToAction.value.appDestination`
   * - `objectStorySpec.linkData.callToAction.value.appLink`
   * - `objectStorySpec.linkData.callToAction.value.application`
   * - `objectStorySpec.linkData.callToAction.value.link`
   * - `objectStorySpec.linkData.callToAction.value.linkCaption`
   * - `objectStorySpec.linkData.callToAction.value.page`
   * - `objectStorySpec.pageId`
   * - `objectStorySpec.postExternalId`
   * - `objectStorySpec.callToActionType`
   * - `postId`
   * - `name`
   * - `externalId`
   * - `id`
   * - `created`
   * - `updated`
   * - `post.type`
   * - `post.status`
   * - `post.createdExternally`
   * - `post.content`
   * - `post.locationId`
   * - `post.scheduleAt`
   * - `post.publishedAt`
   * - `post.settings.google.languageCode`
   * - `post.settings.google.callToAction.actionType`
   * - `post.settings.google.callToAction.url`
   * - `post.settings.google.error`
   * - `post.settings.google.createdTime`
   * - `post.settings.google.updatedTime`
   * - `post.settings.google.externalId`
   * - `post.settings.google.publishOnListingService`
   * - `post.settings.google.status`
   * - `post.settings.google.content`
   * - `post.settings.google.permalinkUrl`
   * - `post.settings.google.errorMessage`
   * - `post.settings.google.publishedAt`
   * - `post.settings.google.requireListingUpdate`
   * - `post.settings.google.created`
   * - `post.settings.google.updated`
   * - `post.settings.facebook.views`
   * - `post.settings.facebook.likes`
   * - `post.settings.facebook.shares`
   * - `post.settings.facebook.error`
   * - `post.settings.facebook.createdTime`
   * - `post.settings.facebook.updatedTime`
   * - `post.settings.facebook.externalId`
   * - `post.settings.facebook.publishOnListingService`
   * - `post.settings.facebook.status`
   * - `post.settings.facebook.content`
   * - `post.settings.facebook.permalinkUrl`
   * - `post.settings.facebook.errorMessage`
   * - `post.settings.facebook.publishedAt`
   * - `post.settings.facebook.requireListingUpdate`
   * - `post.settings.instagram.error.type`
   * - `post.settings.instagram.error.message`
   * - `post.settings.instagram.error.code`
   * - `post.settings.instagram.owner.id`
   * - `post.settings.instagram.likes`
   * - `post.settings.instagram.comments`
   * - `post.settings.instagram.createdTime`
   * - `post.settings.instagram.updatedTime`
   * - `post.settings.instagram.externalId`
   * - `post.settings.instagram.publishOnListingService`
   * - `post.settings.instagram.status`
   * - `post.settings.instagram.content`
   * - `post.settings.instagram.permalinkUrl`
   * - `post.settings.instagram.errorMessage`
   * - `post.settings.instagram.publishedAt`
   * - `post.settings.instagram.requireListingUpdate`
   * - `post.settings.instagram.created`
   * - `post.settings.instagram.updated`
   * - `post.id`
   * - `post.created`
   * - `post.updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `post`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`</details>
   */
  expand?: string;
};
export type DeleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsBoostAdCreativeListByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientAdsLocationsBoostAdSetsCreateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `bidAmount`
   * - `dailyBudget`
   * - `billingEvent`
   * - `boostCampaignId`
   * - `externalId`
   * - `name`
   * - `optimizationGoal`
   * - `startTime`
   * - `stopTime`
   * - `status`
   * - `destinationType`
   * - `targeting.ageMin`
   * - `targeting.ageMax`
   * - `targeting.externalId`
   * - `targeting.audienceType`
   * - `targeting.facebookPositions`
   * - `targeting.genders`
   * - `id`
   * - `created`
   * - `updated`
   * - `ads.boostAdSetId`
   * - `ads.boostAdCreativeId`
   * - `ads.externalId`
   * - `ads.name`
   * - `ads.status`
   * - `ads.previewShareableLink`
   * - `ads.id`
   * - `ads.created`
   * - `ads.updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `bidAmount`
   * - `dailyBudget`
   * - `billingEvent`
   * - `boostCampaignId`
   * - `externalId`
   * - `name`
   * - `optimizationGoal`
   * - `startTime`
   * - `stopTime`
   * - `status`
   * - `destinationType`
   * - `targeting.ageMin`
   * - `targeting.ageMax`
   * - `targeting.externalId`
   * - `targeting.audienceType`
   * - `targeting.facebookPositions`
   * - `targeting.genders`
   * - `id`
   * - `created`
   * - `updated`
   * - `ads.boostAdSetId`
   * - `ads.boostAdCreativeId`
   * - `ads.externalId`
   * - `ads.name`
   * - `ads.status`
   * - `ads.previewShareableLink`
   * - `ads.id`
   * - `ads.created`
   * - `ads.updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `ads`
   *   - Allowed filter properties are:
   *     - `boostAdSetId`
   *     - `boostAdCreativeId`
   *     - `externalId`
   *     - `name`
   *     - `status`
   *     - `previewShareableLink`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `boostAdSetId`
   *     - `boostAdCreativeId`
   *     - `externalId`
   *     - `name`
   *     - `status`
   *     - `previewShareableLink`
   *     - `id`
   *     - `created`
   *     - `updated`</details>
   */
  expand?: string;
};
export type PostClientAdsLocationsBoostAdSetsDeleteByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientAdsLocationsBoostAdSetsUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsBoostAudienceByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsBoostCampaignsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `adAccountId`
   * - `status`
   * - `objective`
   * - `externalId`
   * - `name`
   * - `createdExternally`
   * - `id`
   * - `created`
   * - `updated`
   * - `adSets.bidAmount`
   * - `adSets.dailyBudget`
   * - `adSets.billingEvent`
   * - `adSets.boostCampaignId`
   * - `adSets.externalId`
   * - `adSets.name`
   * - `adSets.optimizationGoal`
   * - `adSets.startTime`
   * - `adSets.stopTime`
   * - `adSets.status`
   * - `adSets.destinationType`
   * - `adSets.targeting.ageMin`
   * - `adSets.targeting.ageMax`
   * - `adSets.targeting.externalId`
   * - `adSets.targeting.audienceType`
   * - `adSets.targeting.facebookPositions`
   * - `adSets.targeting.genders`
   * - `adSets.id`
   * - `adSets.created`
   * - `adSets.updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `adAccountId`
   * - `status`
   * - `objective`
   * - `externalId`
   * - `name`
   * - `createdExternally`
   * - `id`
   * - `created`
   * - `updated`
   * - `adSets.bidAmount`
   * - `adSets.dailyBudget`
   * - `adSets.billingEvent`
   * - `adSets.boostCampaignId`
   * - `adSets.externalId`
   * - `adSets.name`
   * - `adSets.optimizationGoal`
   * - `adSets.startTime`
   * - `adSets.stopTime`
   * - `adSets.status`
   * - `adSets.destinationType`
   * - `adSets.targeting.ageMin`
   * - `adSets.targeting.ageMax`
   * - `adSets.targeting.externalId`
   * - `adSets.targeting.audienceType`
   * - `adSets.targeting.facebookPositions`
   * - `adSets.targeting.genders`
   * - `adSets.id`
   * - `adSets.created`
   * - `adSets.updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `adSets`
   *   - Allowed filter properties are:
   *     - `bidAmount`
   *     - `dailyBudget`
   *     - `billingEvent`
   *     - `boostCampaignId`
   *     - `externalId`
   *     - `name`
   *     - `optimizationGoal`
   *     - `startTime`
   *     - `stopTime`
   *     - `status`
   *     - `destinationType`
   *     - `targeting.ageMin`
   *     - `targeting.ageMax`
   *     - `targeting.externalId`
   *     - `targeting.audienceType`
   *     - `targeting.facebookPositions`
   *     - `targeting.genders`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `bidAmount`
   *     - `dailyBudget`
   *     - `billingEvent`
   *     - `boostCampaignId`
   *     - `externalId`
   *     - `name`
   *     - `optimizationGoal`
   *     - `startTime`
   *     - `stopTime`
   *     - `status`
   *     - `destinationType`
   *     - `targeting.ageMin`
   *     - `targeting.ageMax`
   *     - `targeting.externalId`
   *     - `targeting.audienceType`
   *     - `targeting.facebookPositions`
   *     - `targeting.genders`
   *     - `id`
   *     - `created`
   *     - `updated`</details>
   */
  expand?: string;
};
export type PatchClientAdsLocationsBoostCampaignsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientAdsLocationsBoostCampaignsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `adAccountId`
   * - `status`
   * - `objective`
   * - `externalId`
   * - `name`
   * - `createdExternally`
   * - `id`
   * - `created`
   * - `updated`
   * - `adSets.bidAmount`
   * - `adSets.dailyBudget`
   * - `adSets.billingEvent`
   * - `adSets.boostCampaignId`
   * - `adSets.externalId`
   * - `adSets.name`
   * - `adSets.optimizationGoal`
   * - `adSets.startTime`
   * - `adSets.stopTime`
   * - `adSets.status`
   * - `adSets.destinationType`
   * - `adSets.targeting.ageMin`
   * - `adSets.targeting.ageMax`
   * - `adSets.targeting.externalId`
   * - `adSets.targeting.audienceType`
   * - `adSets.targeting.facebookPositions`
   * - `adSets.targeting.genders`
   * - `adSets.id`
   * - `adSets.created`
   * - `adSets.updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `adAccountId`
   * - `status`
   * - `objective`
   * - `externalId`
   * - `name`
   * - `createdExternally`
   * - `id`
   * - `created`
   * - `updated`
   * - `adSets.bidAmount`
   * - `adSets.dailyBudget`
   * - `adSets.billingEvent`
   * - `adSets.boostCampaignId`
   * - `adSets.externalId`
   * - `adSets.name`
   * - `adSets.optimizationGoal`
   * - `adSets.startTime`
   * - `adSets.stopTime`
   * - `adSets.status`
   * - `adSets.destinationType`
   * - `adSets.targeting.ageMin`
   * - `adSets.targeting.ageMax`
   * - `adSets.targeting.externalId`
   * - `adSets.targeting.audienceType`
   * - `adSets.targeting.facebookPositions`
   * - `adSets.targeting.genders`
   * - `adSets.id`
   * - `adSets.created`
   * - `adSets.updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `adSets`
   *   - Allowed filter properties are:
   *     - `bidAmount`
   *     - `dailyBudget`
   *     - `billingEvent`
   *     - `boostCampaignId`
   *     - `externalId`
   *     - `name`
   *     - `optimizationGoal`
   *     - `startTime`
   *     - `stopTime`
   *     - `status`
   *     - `destinationType`
   *     - `targeting.ageMin`
   *     - `targeting.ageMax`
   *     - `targeting.externalId`
   *     - `targeting.audienceType`
   *     - `targeting.facebookPositions`
   *     - `targeting.genders`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `bidAmount`
   *     - `dailyBudget`
   *     - `billingEvent`
   *     - `boostCampaignId`
   *     - `externalId`
   *     - `name`
   *     - `optimizationGoal`
   *     - `startTime`
   *     - `stopTime`
   *     - `status`
   *     - `destinationType`
   *     - `targeting.ageMin`
   *     - `targeting.ageMax`
   *     - `targeting.externalId`
   *     - `targeting.audienceType`
   *     - `targeting.facebookPositions`
   *     - `targeting.genders`
   *     - `id`
   *     - `created`
   *     - `updated`</details>
   */
  expand?: string;
};
export type DeleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `adAccountId`
   * - `status`
   * - `objective`
   * - `externalId`
   * - `name`
   * - `createdExternally`
   * - `id`
   * - `created`
   * - `updated`
   * - `adSets.bidAmount`
   * - `adSets.dailyBudget`
   * - `adSets.billingEvent`
   * - `adSets.boostCampaignId`
   * - `adSets.externalId`
   * - `adSets.name`
   * - `adSets.optimizationGoal`
   * - `adSets.startTime`
   * - `adSets.stopTime`
   * - `adSets.status`
   * - `adSets.destinationType`
   * - `adSets.targeting.ageMin`
   * - `adSets.targeting.ageMax`
   * - `adSets.targeting.externalId`
   * - `adSets.targeting.audienceType`
   * - `adSets.targeting.facebookPositions`
   * - `adSets.targeting.genders`
   * - `adSets.id`
   * - `adSets.created`
   * - `adSets.updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `adAccountId`
   * - `status`
   * - `objective`
   * - `externalId`
   * - `name`
   * - `createdExternally`
   * - `id`
   * - `created`
   * - `updated`
   * - `adSets.bidAmount`
   * - `adSets.dailyBudget`
   * - `adSets.billingEvent`
   * - `adSets.boostCampaignId`
   * - `adSets.externalId`
   * - `adSets.name`
   * - `adSets.optimizationGoal`
   * - `adSets.startTime`
   * - `adSets.stopTime`
   * - `adSets.status`
   * - `adSets.destinationType`
   * - `adSets.targeting.ageMin`
   * - `adSets.targeting.ageMax`
   * - `adSets.targeting.externalId`
   * - `adSets.targeting.audienceType`
   * - `adSets.targeting.facebookPositions`
   * - `adSets.targeting.genders`
   * - `adSets.id`
   * - `adSets.created`
   * - `adSets.updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `adSets`
   *   - Allowed filter properties are:
   *     - `bidAmount`
   *     - `dailyBudget`
   *     - `billingEvent`
   *     - `boostCampaignId`
   *     - `externalId`
   *     - `name`
   *     - `optimizationGoal`
   *     - `startTime`
   *     - `stopTime`
   *     - `status`
   *     - `destinationType`
   *     - `targeting.ageMin`
   *     - `targeting.ageMax`
   *     - `targeting.externalId`
   *     - `targeting.audienceType`
   *     - `targeting.facebookPositions`
   *     - `targeting.genders`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `bidAmount`
   *     - `dailyBudget`
   *     - `billingEvent`
   *     - `boostCampaignId`
   *     - `externalId`
   *     - `name`
   *     - `optimizationGoal`
   *     - `startTime`
   *     - `stopTime`
   *     - `status`
   *     - `destinationType`
   *     - `targeting.ageMin`
   *     - `targeting.ageMax`
   *     - `targeting.externalId`
   *     - `targeting.audienceType`
   *     - `targeting.facebookPositions`
   *     - `targeting.genders`
   *     - `id`
   *     - `created`
   *     - `updated`</details>
   */
  expand?: string;
};
export type PatchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PutClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `adAccountId`
   * - `status`
   * - `objective`
   * - `externalId`
   * - `name`
   * - `createdExternally`
   * - `id`
   * - `created`
   * - `updated`
   * - `adSets.bidAmount`
   * - `adSets.dailyBudget`
   * - `adSets.billingEvent`
   * - `adSets.boostCampaignId`
   * - `adSets.externalId`
   * - `adSets.name`
   * - `adSets.optimizationGoal`
   * - `adSets.startTime`
   * - `adSets.stopTime`
   * - `adSets.status`
   * - `adSets.destinationType`
   * - `adSets.targeting.ageMin`
   * - `adSets.targeting.ageMax`
   * - `adSets.targeting.externalId`
   * - `adSets.targeting.audienceType`
   * - `adSets.targeting.facebookPositions`
   * - `adSets.targeting.genders`
   * - `adSets.id`
   * - `adSets.created`
   * - `adSets.updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `adAccountId`
   * - `status`
   * - `objective`
   * - `externalId`
   * - `name`
   * - `createdExternally`
   * - `id`
   * - `created`
   * - `updated`
   * - `adSets.bidAmount`
   * - `adSets.dailyBudget`
   * - `adSets.billingEvent`
   * - `adSets.boostCampaignId`
   * - `adSets.externalId`
   * - `adSets.name`
   * - `adSets.optimizationGoal`
   * - `adSets.startTime`
   * - `adSets.stopTime`
   * - `adSets.status`
   * - `adSets.destinationType`
   * - `adSets.targeting.ageMin`
   * - `adSets.targeting.ageMax`
   * - `adSets.targeting.externalId`
   * - `adSets.targeting.audienceType`
   * - `adSets.targeting.facebookPositions`
   * - `adSets.targeting.genders`
   * - `adSets.id`
   * - `adSets.created`
   * - `adSets.updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `adSets`
   *   - Allowed filter properties are:
   *     - `bidAmount`
   *     - `dailyBudget`
   *     - `billingEvent`
   *     - `boostCampaignId`
   *     - `externalId`
   *     - `name`
   *     - `optimizationGoal`
   *     - `startTime`
   *     - `stopTime`
   *     - `status`
   *     - `destinationType`
   *     - `targeting.ageMin`
   *     - `targeting.ageMax`
   *     - `targeting.externalId`
   *     - `targeting.audienceType`
   *     - `targeting.facebookPositions`
   *     - `targeting.genders`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `bidAmount`
   *     - `dailyBudget`
   *     - `billingEvent`
   *     - `boostCampaignId`
   *     - `externalId`
   *     - `name`
   *     - `optimizationGoal`
   *     - `startTime`
   *     - `stopTime`
   *     - `status`
   *     - `destinationType`
   *     - `targeting.ageMin`
   *     - `targeting.ageMax`
   *     - `targeting.externalId`
   *     - `targeting.audienceType`
   *     - `targeting.facebookPositions`
   *     - `targeting.genders`
   *     - `id`
   *     - `created`
   *     - `updated`</details>
   */
  expand?: string;
};
export type PostClientAdsLocationsBoostInsightsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Used when trying to get Insights for a single Element of a Level (ad, adset, campaign). Does not work with level account.
   */
  queryId?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsPostIsInstagramEligibleByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * The Post id
   */
  postId: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientAdsLocationsBoostTargetingGeolocationByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * The input we search locations for
   */
  searchInput: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};

export class AdsStore extends HttpStore {
  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsAdAccountByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get details about an AdAccount
   */

  /**
   * AdAccount Details
   * Get details about an AdAccount
   */
  getClientAdsLocationsAdAccountByLocationId(
    locationId: number,
    queryParams: GetClientAdsLocationsAdAccountByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<AdAccountGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/ads/locations/${locationId}/adAccount`), queryParams, signal);
  }

  static getClientAdsLocationsAdAccountByLocationIdThunk = createAsyncThunk<
    AdAccountGetResponseDto,
    { locationId: number; queryParams: GetClientAdsLocationsAdAccountByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * AdAccount Details
     * Get details about an AdAccount
     */
    'getClientAdsLocationsAdAccountByLocationId',
    async (
      { locationId, queryParams }: { locationId: number; queryParams: GetClientAdsLocationsAdAccountByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsAdAccountByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsAdAccountByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsAdAccountByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsAdAccountByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsAdAccountByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/adAccount',
  );
  static getClientAdsLocationsAdAccountByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/adAccount(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientAdsLocationsAdAccountUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates an AdAccount
   */

  /**
   * Update AdAccount
   * Updates an AdAccount
   */
  patchClientAdsLocationsAdAccountUpdateByLocationId(
    locationId: number,
    requestBody: AdAccountUpdateRequestDto,
    queryParams: PatchClientAdsLocationsAdAccountUpdateByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<AdAccountGetResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/adAccount/update`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientAdsLocationsAdAccountUpdateByLocationIdThunk = createAsyncThunk<
    AdAccountGetResponseDto,
    {
      locationId: number;
      requestBody: AdAccountUpdateRequestDto;
      queryParams: PatchClientAdsLocationsAdAccountUpdateByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * Update AdAccount
     * Updates an AdAccount
     */
    'patchClientAdsLocationsAdAccountUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: AdAccountUpdateRequestDto;
        queryParams: PatchClientAdsLocationsAdAccountUpdateByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientAdsLocationsAdAccountUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.patchClientAdsLocationsAdAccountUpdateByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsAdAccountUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsAdAccountUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientAdsLocationsAdAccountUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/adAccount/update',
  );
  static patchClientAdsLocationsAdAccountUpdateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/adAccount/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsAdAccountUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates an AdAccount
   */

  /**
   * Update AdAccount
   * Updates an AdAccount
   */
  postClientAdsLocationsAdAccountUpdateByLocationId(
    locationId: number,
    requestBody: AdAccountUpdateRequestDto,
    queryParams: PostClientAdsLocationsAdAccountUpdateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<AdAccountGetResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/adAccount/update`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsAdAccountUpdateByLocationIdThunk = createAsyncThunk<
    AdAccountGetResponseDto,
    {
      locationId: number;
      requestBody: AdAccountUpdateRequestDto;
      queryParams: PostClientAdsLocationsAdAccountUpdateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * Update AdAccount
     * Updates an AdAccount
     */
    'postClientAdsLocationsAdAccountUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: AdAccountUpdateRequestDto;
        queryParams: PostClientAdsLocationsAdAccountUpdateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsAdAccountUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsAdAccountUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsAdAccountUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsAdAccountUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsAdAccountUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/adAccount/update',
  );
  static postClientAdsLocationsAdAccountUpdateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/adAccount/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsAdAccountEstimateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get boost reach estimations
   */

  /**
   * Get boost reach estimations
   * Get boost reach estimations
   */
  postClientAdsLocationsAdAccountEstimateByLocationId(
    locationId: number,
    requestBody: BoostAdAccountReachEstimateGetRequestDto,
    queryParams: PostClientAdsLocationsAdAccountEstimateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<BoostAdAccountReachEstimateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/adAccount/estimate`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsAdAccountEstimateByLocationIdThunk = createAsyncThunk<
    BoostAdAccountReachEstimateResponseDto,
    {
      locationId: number;
      requestBody: BoostAdAccountReachEstimateGetRequestDto;
      queryParams: PostClientAdsLocationsAdAccountEstimateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Get boost reach estimations
     * Get boost reach estimations
     */
    'postClientAdsLocationsAdAccountEstimateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: BoostAdAccountReachEstimateGetRequestDto;
        queryParams: PostClientAdsLocationsAdAccountEstimateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsAdAccountEstimateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsAdAccountEstimateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsAdAccountEstimateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsAdAccountEstimateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsAdAccountEstimateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/adAccount/estimate',
  );
  static postClientAdsLocationsAdAccountEstimateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/adAccount/estimate(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsAdAccountMetaAdAccountsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns the list of Mata Ad Accounts for the location
   */

  /**
   * Location AdAccounts Details
   * Returns the list of Mata Ad Accounts for the location
   */
  getClientAdsLocationsAdAccountMetaAdAccountsByLocationId(
    locationId: number,
    queryParams: GetClientAdsLocationsAdAccountMetaAdAccountsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<MetaAdAccountsGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/adAccount/metaAdAccounts`),
      queryParams,
      signal,
    );
  }

  static getClientAdsLocationsAdAccountMetaAdAccountsByLocationIdThunk = createAsyncThunk<
    MetaAdAccountsGetResponseDto,
    { locationId: number; queryParams: GetClientAdsLocationsAdAccountMetaAdAccountsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * Location AdAccounts Details
     * Returns the list of Mata Ad Accounts for the location
     */
    'getClientAdsLocationsAdAccountMetaAdAccountsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientAdsLocationsAdAccountMetaAdAccountsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsAdAccountMetaAdAccountsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsAdAccountMetaAdAccountsByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsAdAccountMetaAdAccountsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsAdAccountMetaAdAccountsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsAdAccountMetaAdAccountsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/adAccount/metaAdAccounts',
  );
  static getClientAdsLocationsAdAccountMetaAdAccountsByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/adAccount/metaAdAccounts(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update MetaAdAccountSettings on Location's AdAccount
   */

  /**
   * Update Meta AdAccount Details
   * Update MetaAdAccountSettings on Location's AdAccount
   */
  patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationId(
    locationId: number,
    requestBody: MetaAdAccountUpdateRequestDto,
    queryParams: PatchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<MetaAdAccountUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/adAccount/metaAdAccounts/update`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdThunk = createAsyncThunk<
    MetaAdAccountUpdateResponseDto,
    {
      locationId: number;
      requestBody: MetaAdAccountUpdateRequestDto;
      queryParams: PatchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | ForbiddenException;
    }
  >(
    /**
     * Update Meta AdAccount Details
     * Update MetaAdAccountSettings on Location's AdAccount
     */
    'patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: MetaAdAccountUpdateRequestDto;
        queryParams: PatchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/adAccount/metaAdAccounts/update',
  );
  static patchClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/adAccount/metaAdAccounts/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update MetaAdAccountSettings on Location's AdAccount
   */

  /**
   * Update Meta AdAccount Details
   * Update MetaAdAccountSettings on Location's AdAccount
   */
  postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationId(
    locationId: number,
    requestBody: MetaAdAccountUpdateRequestDto,
    queryParams: PostClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<MetaAdAccountUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/adAccount/metaAdAccounts/update`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdThunk = createAsyncThunk<
    MetaAdAccountUpdateResponseDto,
    {
      locationId: number;
      requestBody: MetaAdAccountUpdateRequestDto;
      queryParams: PostClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | ForbiddenException;
    }
  >(
    /**
     * Update Meta AdAccount Details
     * Update MetaAdAccountSettings on Location's AdAccount
     */
    'postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: MetaAdAccountUpdateRequestDto;
        queryParams: PostClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/adAccount/metaAdAccounts/update',
  );
  static postClientAdsLocationsAdAccountMetaAdAccountsUpdateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/adAccount/metaAdAccounts/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns payment details for Meta AdAccount
   */

  /**
   * Returns payment details for Meta AdAccount
   * Returns payment details for Meta AdAccount
   */
  getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountId(
    metaAdAccountId: string,
    locationId: number,
    queryParams: GetClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdOpts,
    signal?: AbortSignal,
  ): Observable<MetaAdAccountGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/adAccount/metaAdAccount/${metaAdAccountId}/payment`),
      queryParams,
      signal,
    );
  }

  static getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdThunk = createAsyncThunk<
    MetaAdAccountGetResponseDto,
    {
      metaAdAccountId: string;
      locationId: number;
      queryParams: GetClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Returns payment details for Meta AdAccount
     * Returns payment details for Meta AdAccount
     */
    'getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountId',
    async (
      {
        metaAdAccountId,
        locationId,
        queryParams,
      }: {
        metaAdAccountId: string;
        locationId: number;
        queryParams: GetClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountId(
            metaAdAccountId,
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/adAccount/metaAdAccount/{metaAdAccountId}/payment',
  );
  static getClientAdsLocationsAdAccountMetaAdAccountPaymentByMetaAdAccountIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/adAccount/metaAdAccount/{metaAdAccountId}/payment(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsBoostAdUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update/Create BoostAd
   */

  /**
   * Update/Create Boost Ad
   * Update/Create BoostAd
   */
  postClientAdsLocationsBoostAdUpdateByLocationId(
    locationId: number,
    requestBody: BoostAdPostRequestDto,
    queryParams: PostClientAdsLocationsBoostAdUpdateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<BoostAdPostResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAd/update`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsBoostAdUpdateByLocationIdThunk = createAsyncThunk<
    BoostAdPostResponseDto,
    {
      locationId: number;
      requestBody: BoostAdPostRequestDto;
      queryParams: PostClientAdsLocationsBoostAdUpdateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | UnauthorizedException | InternalErrorException;
    }
  >(
    /**
     * Update/Create Boost Ad
     * Update/Create BoostAd
     */
    'postClientAdsLocationsBoostAdUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: BoostAdPostRequestDto;
        queryParams: PostClientAdsLocationsBoostAdUpdateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsBoostAdUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsBoostAdUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostAdUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostAdUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsBoostAdUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAd/update',
  );
  static postClientAdsLocationsBoostAdUpdateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAd/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientAdsLocationsBoostAdDeleteByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Delete BoostAd
   */

  /**
   * Delete Boost Ad
   * Delete BoostAd
   */
  deleteClientAdsLocationsBoostAdDeleteByLocationId(
    locationId: number,
    requestBody: BoostAdRequestDto,
    queryParams: DeleteClientAdsLocationsBoostAdDeleteByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostAdPostResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAd/delete`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientAdsLocationsBoostAdDeleteByLocationIdThunk = createAsyncThunk<
    BoostAdPostResponseDto,
    {
      locationId: number;
      requestBody: BoostAdRequestDto;
      queryParams: DeleteClientAdsLocationsBoostAdDeleteByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * Delete Boost Ad
     * Delete BoostAd
     */
    'deleteClientAdsLocationsBoostAdDeleteByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: BoostAdRequestDto;
        queryParams: DeleteClientAdsLocationsBoostAdDeleteByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientAdsLocationsBoostAdDeleteByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.deleteClientAdsLocationsBoostAdDeleteByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientAdsLocationsBoostAdDeleteByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientAdsLocationsBoostAdDeleteByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientAdsLocationsBoostAdDeleteByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAd/delete',
  );
  static deleteClientAdsLocationsBoostAdDeleteByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAd/delete(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsBoostAdCreativeUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update/Create BoostAdCreative
   */

  /**
   * Update/Create Boost Ad Creative
   * Update/Create BoostAdCreative
   */
  postClientAdsLocationsBoostAdCreativeUpdateByLocationId(
    locationId: number,
    requestBody: BoostAdCreativePostRequestDto,
    queryParams: PostClientAdsLocationsBoostAdCreativeUpdateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<BoostAdCreativePostResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAdCreative/update`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsBoostAdCreativeUpdateByLocationIdThunk = createAsyncThunk<
    BoostAdCreativePostResponseDto,
    {
      locationId: number;
      requestBody: BoostAdCreativePostRequestDto;
      queryParams: PostClientAdsLocationsBoostAdCreativeUpdateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | InternalErrorException;
    }
  >(
    /**
     * Update/Create Boost Ad Creative
     * Update/Create BoostAdCreative
     */
    'postClientAdsLocationsBoostAdCreativeUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: BoostAdCreativePostRequestDto;
        queryParams: PostClientAdsLocationsBoostAdCreativeUpdateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsBoostAdCreativeUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsBoostAdCreativeUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostAdCreativeUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostAdCreativeUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsBoostAdCreativeUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAdCreative/update',
  );
  static postClientAdsLocationsBoostAdCreativeUpdateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAdCreative/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Delete BoostAdCreative
   */

  /**
   * Delete Boost Ad Creative
   * Delete BoostAdCreative
   */
  deleteClientAdsLocationsBoostAdCreativeDeleteByLocationId(
    locationId: number,
    requestBody: BoostAdCreativeRequestDto,
    queryParams: DeleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostAdCreativeDeleteResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAdCreative/delete`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdThunk = createAsyncThunk<
    BoostAdCreativeDeleteResponseDto,
    {
      locationId: number;
      requestBody: BoostAdCreativeRequestDto;
      queryParams: DeleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | UnauthorizedException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Delete Boost Ad Creative
     * Delete BoostAdCreative
     */
    'deleteClientAdsLocationsBoostAdCreativeDeleteByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: BoostAdCreativeRequestDto;
        queryParams: DeleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.deleteClientAdsLocationsBoostAdCreativeDeleteByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAdCreative/delete',
  );
  static deleteClientAdsLocationsBoostAdCreativeDeleteByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAdCreative/delete(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsBoostAdCreativeListByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get list of AdCreatives of an ad account
   */

  /**
   * AdCreatives List of an ad account
   * Get list of AdCreatives of an ad account
   */
  getClientAdsLocationsBoostAdCreativeListByLocationId(
    locationId: number,
    queryParams: GetClientAdsLocationsBoostAdCreativeListByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostAdCreativesGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAdCreative/list`),
      queryParams,
      signal,
    );
  }

  static getClientAdsLocationsBoostAdCreativeListByLocationIdThunk = createAsyncThunk<
    BoostAdCreativesGetResponseDto,
    { locationId: number; queryParams: GetClientAdsLocationsBoostAdCreativeListByLocationIdOpts },
    {
      rejectValue: BadRequestException | UnauthorizedException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * AdCreatives List of an ad account
     * Get list of AdCreatives of an ad account
     */
    'getClientAdsLocationsBoostAdCreativeListByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientAdsLocationsBoostAdCreativeListByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsBoostAdCreativeListByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsBoostAdCreativeListByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostAdCreativeListByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostAdCreativeListByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsBoostAdCreativeListByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAdCreative/list',
  );
  static getClientAdsLocationsBoostAdCreativeListByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAdCreative/list(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get AdCreative based on id
   */

  /**
   * AdCreative of an ad account
   * Get AdCreative based on id
   */
  getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationId(
    boostAdCreativeId: number,
    locationId: number,
    queryParams: GetClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostAdCreativeGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAdCreative/${boostAdCreativeId}`),
      queryParams,
      signal,
    );
  }

  static getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdThunk = createAsyncThunk<
    BoostAdCreativeGetResponseDto,
    {
      boostAdCreativeId: number;
      locationId: number;
      queryParams: GetClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | UnauthorizedException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * AdCreative of an ad account
     * Get AdCreative based on id
     */
    'getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationId',
    async (
      {
        boostAdCreativeId,
        locationId,
        queryParams,
      }: {
        boostAdCreativeId: number;
        locationId: number;
        queryParams: GetClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationId(
            boostAdCreativeId,
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAdCreative/{boostAdCreativeId}',
  );
  static getClientAdsLocationsBoostAdCreativeByBoostAdCreativeIdByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAdCreative/{boostAdCreativeId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsBoostAdSetsCreateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * BoostAdSets Create
   */

  /**
   * BoostAdSets Create
   * BoostAdSets Create
   */
  postClientAdsLocationsBoostAdSetsCreateByLocationId(
    locationId: number,
    requestBody: BoostAdSetPostRequestDto,
    queryParams: PostClientAdsLocationsBoostAdSetsCreateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<BoostAdSetPostResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAdSets/create`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsBoostAdSetsCreateByLocationIdThunk = createAsyncThunk<
    BoostAdSetPostResponseDto,
    {
      locationId: number;
      requestBody: BoostAdSetPostRequestDto;
      queryParams: PostClientAdsLocationsBoostAdSetsCreateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | InternalErrorException;
    }
  >(
    /**
     * BoostAdSets Create
     * BoostAdSets Create
     */
    'postClientAdsLocationsBoostAdSetsCreateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: BoostAdSetPostRequestDto;
        queryParams: PostClientAdsLocationsBoostAdSetsCreateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsBoostAdSetsCreateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsBoostAdSetsCreateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostAdSetsCreateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostAdSetsCreateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsBoostAdSetsCreateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAdSets/create',
  );
  static postClientAdsLocationsBoostAdSetsCreateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAdSets/create(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsBoostAdSetsDeleteByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * BoostAdSets Create
   */

  /**
   * BoostAdSets Delete
   * BoostAdSets Create
   */
  postClientAdsLocationsBoostAdSetsDeleteByLocationId(
    locationId: number,
    requestBody: BoostAdSetDeleteRequestDto,
    queryParams: PostClientAdsLocationsBoostAdSetsDeleteByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<BoostAdSetDeleteResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAdSets/delete`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsBoostAdSetsDeleteByLocationIdThunk = createAsyncThunk<
    BoostAdSetDeleteResponseDto,
    {
      locationId: number;
      requestBody: BoostAdSetDeleteRequestDto;
      queryParams: PostClientAdsLocationsBoostAdSetsDeleteByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | InternalErrorException;
    }
  >(
    /**
     * BoostAdSets Delete
     * BoostAdSets Create
     */
    'postClientAdsLocationsBoostAdSetsDeleteByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: BoostAdSetDeleteRequestDto;
        queryParams: PostClientAdsLocationsBoostAdSetsDeleteByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsBoostAdSetsDeleteByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsBoostAdSetsDeleteByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostAdSetsDeleteByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostAdSetsDeleteByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsBoostAdSetsDeleteByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAdSets/delete',
  );
  static postClientAdsLocationsBoostAdSetsDeleteByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAdSets/delete(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * BoostAdSet Reach Estimate
   */

  /**
   * BoostAdSet Reach Estimate
   * BoostAdSet Reach Estimate
   */
  getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetId(
    boostAdSetId: number,
    locationId: number,
    queryParams: GetClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostAdSetReachEstimateResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAdSets/${boostAdSetId}/estimate`),
      queryParams,
      signal,
    );
  }

  static getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdThunk = createAsyncThunk<
    BoostAdSetReachEstimateResponseDto,
    {
      boostAdSetId: number;
      locationId: number;
      queryParams: GetClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostAdSet Reach Estimate
     * BoostAdSet Reach Estimate
     */
    'getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetId',
    async (
      {
        boostAdSetId,
        locationId,
        queryParams,
      }: {
        boostAdSetId: number;
        locationId: number;
        queryParams: GetClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetId(
            boostAdSetId,
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAdSets/{boostAdSetId}/estimate',
  );
  static getClientAdsLocationsBoostAdSetsEstimateByBoostAdSetIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAdSets/{boostAdSetId}/estimate(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientAdsLocationsBoostAdSetsUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * BoostAdSet Update
   */

  /**
   * BoostAdSet Update
   * BoostAdSet Update
   */
  patchClientAdsLocationsBoostAdSetsUpdateByLocationId(
    locationId: number,
    requestBody: BoostAdSetUpdateRequestDto,
    queryParams: PatchClientAdsLocationsBoostAdSetsUpdateByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostAdSetUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAdSets/update`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientAdsLocationsBoostAdSetsUpdateByLocationIdThunk = createAsyncThunk<
    BoostAdSetUpdateResponseDto,
    {
      locationId: number;
      requestBody: BoostAdSetUpdateRequestDto;
      queryParams: PatchClientAdsLocationsBoostAdSetsUpdateByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | UnauthorizedException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostAdSet Update
     * BoostAdSet Update
     */
    'patchClientAdsLocationsBoostAdSetsUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: BoostAdSetUpdateRequestDto;
        queryParams: PatchClientAdsLocationsBoostAdSetsUpdateByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientAdsLocationsBoostAdSetsUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.patchClientAdsLocationsBoostAdSetsUpdateByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsBoostAdSetsUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsBoostAdSetsUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientAdsLocationsBoostAdSetsUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAdSets/update',
  );
  static patchClientAdsLocationsBoostAdSetsUpdateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAdSets/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsBoostAudienceByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * get boost audiences
   */

  /**
   * BoostAudiences get
   * get boost audiences
   */
  getClientAdsLocationsBoostAudienceByLocationId(
    locationId: number,
    queryParams: GetClientAdsLocationsBoostAudienceByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostAudiencesGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/ads/locations/${locationId}/boostAudience`), queryParams, signal);
  }

  static getClientAdsLocationsBoostAudienceByLocationIdThunk = createAsyncThunk<
    BoostAudiencesGetResponseDto,
    { locationId: number; queryParams: GetClientAdsLocationsBoostAudienceByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostAudiences get
     * get boost audiences
     */
    'getClientAdsLocationsBoostAudienceByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientAdsLocationsBoostAudienceByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsBoostAudienceByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsBoostAudienceByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostAudienceByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostAudienceByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsBoostAudienceByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostAudience',
  );
  static getClientAdsLocationsBoostAudienceByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostAudience(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsBoostCampaignsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get an AdAccount's BoostCampaigns
   */

  /**
   * BoostCampaigns List
   * Get an AdAccount's BoostCampaigns
   */
  getClientAdsLocationsBoostCampaignsByLocationId(
    locationId: number,
    queryParams: GetClientAdsLocationsBoostCampaignsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostCampaignsGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/ads/locations/${locationId}/boostCampaigns`), queryParams, signal);
  }

  static getClientAdsLocationsBoostCampaignsByLocationIdThunk = createAsyncThunk<
    BoostCampaignsGetResponseDto,
    { locationId: number; queryParams: GetClientAdsLocationsBoostCampaignsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostCampaigns List
     * Get an AdAccount's BoostCampaigns
     */
    'getClientAdsLocationsBoostCampaignsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientAdsLocationsBoostCampaignsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsBoostCampaignsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsBoostCampaignsByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostCampaignsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostCampaignsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsBoostCampaignsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostCampaigns',
  );
  static getClientAdsLocationsBoostCampaignsByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostCampaigns(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientAdsLocationsBoostCampaignsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Creates or updates a boost campaign and publishes to Meta
   */

  /**
   * BoostCampaign Create/Update & Publish
   * Creates or updates a boost campaign and publishes to Meta
   */
  patchClientAdsLocationsBoostCampaignsByLocationId(
    locationId: number,
    requestBody: BoostCampaignUpdateRequestDto,
    queryParams: PatchClientAdsLocationsBoostCampaignsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostCampaignUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostCampaigns`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientAdsLocationsBoostCampaignsByLocationIdThunk = createAsyncThunk<
    BoostCampaignUpdateResponseDto,
    {
      locationId: number;
      requestBody: BoostCampaignUpdateRequestDto;
      queryParams: PatchClientAdsLocationsBoostCampaignsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostCampaign Create/Update & Publish
     * Creates or updates a boost campaign and publishes to Meta
     */
    'patchClientAdsLocationsBoostCampaignsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: BoostCampaignUpdateRequestDto;
        queryParams: PatchClientAdsLocationsBoostCampaignsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientAdsLocationsBoostCampaignsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.patchClientAdsLocationsBoostCampaignsByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsBoostCampaignsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsBoostCampaignsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientAdsLocationsBoostCampaignsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostCampaigns',
  );
  static patchClientAdsLocationsBoostCampaignsByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostCampaigns(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsBoostCampaignsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Creates or updates a boost campaign and publishes to Meta
   */

  /**
   * BoostCampaign Create/Update & Publish
   * Creates or updates a boost campaign and publishes to Meta
   */
  postClientAdsLocationsBoostCampaignsByLocationId(
    locationId: number,
    requestBody: BoostCampaignUpdateRequestDto,
    queryParams: PostClientAdsLocationsBoostCampaignsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<BoostCampaignUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostCampaigns`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsBoostCampaignsByLocationIdThunk = createAsyncThunk<
    BoostCampaignUpdateResponseDto,
    {
      locationId: number;
      requestBody: BoostCampaignUpdateRequestDto;
      queryParams: PostClientAdsLocationsBoostCampaignsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostCampaign Create/Update & Publish
     * Creates or updates a boost campaign and publishes to Meta
     */
    'postClientAdsLocationsBoostCampaignsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: BoostCampaignUpdateRequestDto;
        queryParams: PostClientAdsLocationsBoostCampaignsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsBoostCampaignsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsBoostCampaignsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostCampaignsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostCampaignsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsBoostCampaignsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostCampaigns',
  );
  static postClientAdsLocationsBoostCampaignsByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostCampaigns(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get details about a BoostCampaign
   */

  /**
   * BoostCampaign Details
   * Get details about a BoostCampaign
   */
  getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationId(
    boostCampaignId: number,
    locationId: number,
    queryParams: GetClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostCampaignUpdateResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostCampaigns/${boostCampaignId}`),
      queryParams,
      signal,
    );
  }

  static getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdThunk = createAsyncThunk<
    BoostCampaignUpdateResponseDto,
    {
      boostCampaignId: number;
      locationId: number;
      queryParams: GetClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostCampaign Details
     * Get details about a BoostCampaign
     */
    'getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationId',
    async (
      {
        boostCampaignId,
        locationId,
        queryParams,
      }: {
        boostCampaignId: number;
        locationId: number;
        queryParams: GetClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationId(
            boostCampaignId,
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}',
  );
  static getClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Deletes a campaign on META
   */

  /**
   * Delete a Boost campaign
   * Deletes a campaign on META
   */
  deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationId(
    boostCampaignId: number,
    locationId: number,
    requestBody: null,
    queryParams: DeleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostCampaignDeleteResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostCampaigns/${boostCampaignId}`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdThunk = createAsyncThunk<
    BoostCampaignDeleteResponseDto,
    {
      boostCampaignId: number;
      locationId: number;
      requestBody: null;
      queryParams: DeleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Delete a Boost campaign
     * Deletes a campaign on META
     */
    'deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationId',
    async (
      {
        boostCampaignId,
        locationId,
        requestBody,
        queryParams,
      }: {
        boostCampaignId: number;
        locationId: number;
        requestBody: null;
        queryParams: DeleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          adsStore.deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationId(
            boostCampaignId,
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}',
  );
  static deleteClientAdsLocationsBoostCampaignsByBoostCampaignIdByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Change campaign status - activate or pause
   */

  /**
   * Change campaign status - activate or pause
   * Change campaign status - activate or pause
   */
  patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignId(
    boostCampaignId: number,
    locationId: number,
    requestBody: BoostCampaignChangeStatusRequestDto,
    queryParams: PatchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostCampaignUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostCampaigns/${boostCampaignId}/changeStatus`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdThunk = createAsyncThunk<
    BoostCampaignUpdateResponseDto,
    {
      boostCampaignId: number;
      locationId: number;
      requestBody: BoostCampaignChangeStatusRequestDto;
      queryParams: PatchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Change campaign status - activate or pause
     * Change campaign status - activate or pause
     */
    'patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignId',
    async (
      {
        boostCampaignId,
        locationId,
        requestBody,
        queryParams,
      }: {
        boostCampaignId: number;
        locationId: number;
        requestBody: BoostCampaignChangeStatusRequestDto;
        queryParams: PatchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          adsStore.patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignId(
            boostCampaignId,
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}/changeStatus',
  );
  static patchClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}/changeStatus(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Change campaign status - activate or pause
   */

  /**
   * Change campaign status - activate or pause
   * Change campaign status - activate or pause
   */
  postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignId(
    boostCampaignId: number,
    locationId: number,
    requestBody: BoostCampaignChangeStatusRequestDto,
    queryParams: PostClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<BoostCampaignUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostCampaigns/${boostCampaignId}/changeStatus`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdThunk = createAsyncThunk<
    BoostCampaignUpdateResponseDto,
    {
      boostCampaignId: number;
      locationId: number;
      requestBody: BoostCampaignChangeStatusRequestDto;
      queryParams: PostClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Change campaign status - activate or pause
     * Change campaign status - activate or pause
     */
    'postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignId',
    async (
      {
        boostCampaignId,
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        boostCampaignId: number;
        locationId: number;
        requestBody: BoostCampaignChangeStatusRequestDto;
        queryParams: PostClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignId(
            boostCampaignId,
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}/changeStatus',
  );
  static postClientAdsLocationsBoostCampaignsChangeStatusByBoostCampaignIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}/changeStatus(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static putClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Creates or updates a campaign on META
   */

  /**
   * Boost a campaign
   * Creates or updates a campaign on META
   */
  putClientAdsLocationsBoostCampaignsBoostByBoostCampaignId(
    boostCampaignId: number,
    locationId: number,
    requestBody: null,
    queryParams: PutClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostCampaignUpdateResponseDto> {
    return this.put(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostCampaigns/${boostCampaignId}/boost`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static putClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdThunk = createAsyncThunk<
    BoostCampaignUpdateResponseDto,
    {
      boostCampaignId: number;
      locationId: number;
      requestBody: null;
      queryParams: PutClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Boost a campaign
     * Creates or updates a campaign on META
     */
    'putClientAdsLocationsBoostCampaignsBoostByBoostCampaignId',
    async (
      {
        boostCampaignId,
        locationId,
        requestBody,
        queryParams,
      }: {
        boostCampaignId: number;
        locationId: number;
        requestBody: null;
        queryParams: PutClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.putClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.putClientAdsLocationsBoostCampaignsBoostByBoostCampaignId(
            boostCampaignId,
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.putClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.putClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static putClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}/boost',
  );
  static putClientAdsLocationsBoostCampaignsBoostByBoostCampaignIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostCampaigns/{boostCampaignId}/boost(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsBoostInsightsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * get boost audiences
   */

  /**
   * BoostAudiences get
   * get boost audiences
   */
  postClientAdsLocationsBoostInsightsByLocationId(
    locationId: number,
    requestBody: BoostInsightsGetRequestDto,
    queryParams: PostClientAdsLocationsBoostInsightsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<BoostInsightsGetResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostInsights`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsBoostInsightsByLocationIdThunk = createAsyncThunk<
    BoostInsightsGetResponseDto,
    {
      locationId: number;
      requestBody: BoostInsightsGetRequestDto;
      queryParams: PostClientAdsLocationsBoostInsightsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostAudiences get
     * get boost audiences
     */
    'postClientAdsLocationsBoostInsightsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: BoostInsightsGetRequestDto;
        queryParams: PostClientAdsLocationsBoostInsightsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsBoostInsightsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsBoostInsightsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostInsightsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsBoostInsightsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsBoostInsightsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostInsights',
  );
  static postClientAdsLocationsBoostInsightsByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostInsights(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsPostIsInstagramEligibleByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get Post eligibility for boosting on instagram
   */

  /**
   * Get instagram eligibility for boosting
   * Get Post eligibility for boosting on instagram
   */
  getClientAdsLocationsPostIsInstagramEligibleByLocationId(
    locationId: number,
    queryParams: GetClientAdsLocationsPostIsInstagramEligibleByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<InstagramEligibilityGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/post/isInstagramEligible`),
      queryParams,
      signal,
    );
  }

  static getClientAdsLocationsPostIsInstagramEligibleByLocationIdThunk = createAsyncThunk<
    InstagramEligibilityGetResponseDto,
    { locationId: number; queryParams: GetClientAdsLocationsPostIsInstagramEligibleByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Get instagram eligibility for boosting
     * Get Post eligibility for boosting on instagram
     */
    'getClientAdsLocationsPostIsInstagramEligibleByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientAdsLocationsPostIsInstagramEligibleByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsPostIsInstagramEligibleByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsPostIsInstagramEligibleByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsPostIsInstagramEligibleByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsPostIsInstagramEligibleByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsPostIsInstagramEligibleByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/post/isInstagramEligible',
  );
  static getClientAdsLocationsPostIsInstagramEligibleByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/post/isInstagramEligible(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientAdsLocationsBoostTargetingGeolocationByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * @return ?BoostGeoLocationGetResponseDto
   */

  /**
   * BoostTargeting location search
   * @return ?BoostGeoLocationGetResponseDto
   */
  getClientAdsLocationsBoostTargetingGeolocationByLocationId(
    locationId: number,
    queryParams: GetClientAdsLocationsBoostTargetingGeolocationByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<BoostGeoLocationGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/boostTargeting/geolocation`),
      queryParams,
      signal,
    );
  }

  static getClientAdsLocationsBoostTargetingGeolocationByLocationIdThunk = createAsyncThunk<
    BoostGeoLocationGetResponseDto,
    { locationId: number; queryParams: GetClientAdsLocationsBoostTargetingGeolocationByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * BoostTargeting location search
     * @return ?BoostGeoLocationGetResponseDto
     */
    'getClientAdsLocationsBoostTargetingGeolocationByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientAdsLocationsBoostTargetingGeolocationByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientAdsLocationsBoostTargetingGeolocationByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          adsStore.getClientAdsLocationsBoostTargetingGeolocationByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostTargetingGeolocationByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientAdsLocationsBoostTargetingGeolocationByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientAdsLocationsBoostTargetingGeolocationByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/boostTargeting/geolocation',
  );
  static getClientAdsLocationsBoostTargetingGeolocationByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/boostTargeting/geolocation(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Validates ResponsiveSearchAd against Google polocies
   */

  /**
   * ResponsiveSearchAd validate
   * Validates ResponsiveSearchAd against Google polocies
   */
  postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationId(
    locationId: number,
    requestBody: ResponsiveSearchAdPostRequestDto,
    queryParams: PostClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<ResponsiveSearchAdResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/google/responsiveSearchAds/validate`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdThunk = createAsyncThunk<
    ResponsiveSearchAdResponseDto,
    {
      locationId: number;
      requestBody: ResponsiveSearchAdPostRequestDto;
      queryParams: PostClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * ResponsiveSearchAd validate
     * Validates ResponsiveSearchAd against Google polocies
     */
    'postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: ResponsiveSearchAdPostRequestDto;
        queryParams: PostClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/google/responsiveSearchAds/validate',
  );
  static postClientAdsLocationsGoogleResponsiveSearchAdsValidateByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/google/responsiveSearchAds/validate(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Cleanse ResponsiveSearchAd Group suggestions
   */

  /**
   * ResponsiveSearchAd Group Suggestions Cleanse
   * Cleanse ResponsiveSearchAd Group suggestions
   */
  patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationId(
    locationId: number,
    requestBody: ResponsiveSearchAdsGroupSuggestionsRequestDto,
    queryParams: PatchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<ResponsiveSearchAdsGroupSuggestionsResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/google/responsiveSearchAds/group/suggestions/cleanse`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdThunk = createAsyncThunk<
    ResponsiveSearchAdsGroupSuggestionsResponseDto,
    {
      locationId: number;
      requestBody: ResponsiveSearchAdsGroupSuggestionsRequestDto;
      queryParams: PatchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * ResponsiveSearchAd Group Suggestions Cleanse
     * Cleanse ResponsiveSearchAd Group suggestions
     */
    'patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: ResponsiveSearchAdsGroupSuggestionsRequestDto;
        queryParams: PatchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          adsStore.patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/google/responsiveSearchAds/group/suggestions/cleanse',
  );
  static patchClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/google/responsiveSearchAds/group/suggestions/cleanse(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Cleanse ResponsiveSearchAd Group suggestions
   */

  /**
   * ResponsiveSearchAd Group Suggestions Cleanse
   * Cleanse ResponsiveSearchAd Group suggestions
   */
  postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationId(
    locationId: number,
    requestBody: ResponsiveSearchAdsGroupSuggestionsRequestDto,
    queryParams: PostClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<ResponsiveSearchAdsGroupSuggestionsResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/ads/locations/${locationId}/google/responsiveSearchAds/group/suggestions/cleanse`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdThunk = createAsyncThunk<
    ResponsiveSearchAdsGroupSuggestionsResponseDto,
    {
      locationId: number;
      requestBody: ResponsiveSearchAdsGroupSuggestionsRequestDto;
      queryParams: PostClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * ResponsiveSearchAd Group Suggestions Cleanse
     * Cleanse ResponsiveSearchAd Group suggestions
     */
    'postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: ResponsiveSearchAdsGroupSuggestionsRequestDto;
        queryParams: PostClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          adsStore.postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/ads/locations/{locationId}/google/responsiveSearchAds/group/suggestions/cleanse',
  );
  static postClientAdsLocationsGoogleResponsiveSearchAdsGroupSuggestionsCleanseByLocationIdUrlMockRequest =
    '/app/api/client/ads/locations/{locationId}/google/responsiveSearchAds/group/suggestions/cleanse(.*)';
}
export const adsStore = new AdsStore();
