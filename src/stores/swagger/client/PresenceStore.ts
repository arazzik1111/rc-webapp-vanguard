/*
 * WARNING THIS FILE IS AUTO-GENERATED DO NOT MODIFY YOUR CHANGES WILL BE OVERWRITTEN!
 */
import type { SocialMediaCommentDeleteResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Comments/SocialMediaCommentDeleteResponseDto';
import type { SocialMediaCommentGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Comments/SocialMediaCommentGetResponseDto';
import type { SocialMediaCommentPostRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Comments/SocialMediaCommentPostRequestDto';
import type { SocialMediaCommentPostResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Comments/SocialMediaCommentPostResponseDto';
import type { SocialMediaCommentReplyAIGenerateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Comments/SocialMediaCommentReplyAIGenerateRequestDto';
import type { SocialMediaCommentReplyAIGenerateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Comments/SocialMediaCommentReplyAIGenerateResponseDto';
import type { SocialMediaCommentsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Comments/SocialMediaCommentsGetResponseDto';
import type { FacebookLocationDisconnectResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FacebookLocation/FacebookLocationDisconnectResponseDto';
import type { FacebookLocationGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FacebookLocation/FacebookLocationGetResponseDto';
import type { FacebookLocationSelectResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FacebookLocation/FacebookLocationSelectResponseDto';
import type { FacebookLocationsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FacebookLocation/FacebookLocationsGetResponseDto';
import type { FacebookLocationUpdateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FacebookLocation/FacebookLocationUpdateResponseDto';
import type { SocialMediaInsightsRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FacebookLocation/SocialMediaInsightsRequestDto';
import type { SocialMediaInsightsResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FacebookLocation/SocialMediaInsightsResponseDto';
import type { FullListingServiceLocationDeactivationResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FullListingServiceLocationDeactivationResponseDto';
import type { FullListingServiceLocationUpdateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/FullListingServiceLocationUpdateResponseDto';
import type { GoogleAttributesPatchRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleAttributesPatchRequestDto';
import type { GoogleAttributesPatchResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleAttributesPatchResponseDto';
import type { GoogleLocationAdminPostRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleLocationAdminPostRequestDto';
import type { GoogleLocationAdminPostResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleLocationAdminPostResponseDto';
import type { GoogleLocationGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleLocationGetResponseDto';
import type { GoogleLocationsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleLocationsGetResponseDto';
import type { GoogleLocationUpdateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleLocationUpdateResponseDto';
import type { GoogleLocationVerificationResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleLocationVerificationResponseDto';
import type { GoogleServiceItemsPatchRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleServiceItemsPatchRequestDto';
import type { GoogleServiceItemsPatchResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleServiceItemsPatchResponseDto';
import type { GoogleTokenSelectLocationResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GoogleLocation/GoogleTokenSelectLocationResponseDto';
import type { GooglePlaceDetailsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GooglePlaces/GooglePlaceDetailsGetResponseDto';
import type { GooglePlacesAutocompleteGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GooglePlaces/GooglePlacesAutocompleteGetResponseDto';
import type { GooglePlacesSearchGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/GooglePlaces/GooglePlacesSearchGetResponseDto';
import type { InterfaceDataSettingRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/InterfaceDataSettingRequestDto';
import type { InterfaceDataSettingResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/InterfaceDataSettingResponseDto';
import type { LocationListingServiceConnectionSyncSettingsUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/ListingServices/LocationListingServiceConnectionSyncSettingsUpdateRequestDto';
import type { LocationListingServiceConnectionSyncSettingsUpdateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/ListingServices/LocationListingServiceConnectionSyncSettingsUpdateResponseDto';
import type { LocationListingServicesGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/ListingServices/LocationListingServicesGetResponseDto';
import type { LocationListingsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/ListingServices/LocationListingsGetResponseDto';
import type { LocationCompanyCompanyVerificationResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/LocationCompanyCompanyVerificationResponseDto';
import type { LocationCompanyCompanyVerificationUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/LocationCompanyCompanyVerificationUpdateRequestDto';
import type { LocationFreeUserGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/LocationFreeUserGetResponseDto';
import type { LocationGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/LocationGetResponseDto';
import type { LocationLocalesGetResponseDTO } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/LocationLocalesGetResponseDTO';
import type { LocationSettingsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/LocationSettingsGetResponseDto';
import type { LocationUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/LocationUpdateRequestDto';
import type { LocationVisibilityIndexGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/LocationVisibilityIndexGetResponseDto';
import type { LocationMediaItemsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/MediaItems/LocationMediaItemsGetResponseDto';
import type { LocationMediaItemsPatchRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/MediaItems/LocationMediaItemsPatchRequestDto';
import type { LocationMediaItemsPostResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/MediaItems/LocationMediaItemsPostResponseDto';
import type { OwnerVerificationDocumentResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/OwnerVerificationDocumentResponseDto';
import type { OwnerVerificationDocumentUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/OwnerVerificationDocumentUpdateRequestDto';
import type { EngagementSummaryResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/EngagementSummaryResponseDto';
import type { EventInstructionGenerateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/EventInstructionGenerateRequestDto';
import type { PostMediaItemsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/MediaItems/PostMediaItemsGetResponseDto';
import type { PostMediaItemsPatchRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/MediaItems/PostMediaItemsPatchRequestDto';
import type { PostMediaItemsPatchResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/MediaItems/PostMediaItemsPatchResponseDto';
import type { PostDeleteResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostDeleteResponseDto';
import type { PostEditRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostEditRequestDto';
import type { PostEditResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostEditResponseDto';
import type { PostInstructionGenerateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostInstructionGenerateRequestDto';
import type { PostsCompetitorsGenerateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostsCompetitorsGenerateRequestDto';
import type { PostsCompetitorsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostsCompetitorsGetResponseDto';
import type { PostsGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostsGetResponseDto';
import type { PostUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostUpdateRequestDto';
import type { PostUpdateResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/Posts/PostUpdateResponseDto';
import type { LocationServiceAreasNotMatchCountryRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/ServiceAreas/LocationServiceAreasNotMatchCountryRequestDto';
import type { ServiceAreasNotMatchCountryResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/ServiceAreas/ServiceAreasNotMatchCountryResponseDto';
import type { UberallLocationGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/UberallLocation/UberallLocationGetResponseDto';
import type { VerificationMediaItemsResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/VerificationMediaItemsResponseDto';
import type { VerificationMediaItemsUpdateRequestDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/VerificationMediaItemsUpdateRequestDto';
import type { YextLocationGetResponseDto } from '@models/swagger/App/Presentation/Api/Client/Presence/Locations/Dtos/YextLocation/YextLocationGetResponseDto';
import type { BadRequestException } from '@models/swagger/DDD/Infrastructure/Exceptions/BadRequestException';
import type { ForbiddenException } from '@models/swagger/DDD/Infrastructure/Exceptions/ForbiddenException';
import type { InternalErrorException } from '@models/swagger/DDD/Infrastructure/Exceptions/InternalErrorException';
import type { MethodNotAllowedException } from '@models/swagger/DDD/Infrastructure/Exceptions/MethodNotAllowedException';
import type { NotFoundException } from '@models/swagger/DDD/Infrastructure/Exceptions/NotFoundException';
import type { UnauthorizedException } from '@models/swagger/DDD/Infrastructure/Exceptions/UnauthorizedException';
import { createAsyncThunk } from '@reduxjs/toolkit';
import { firstValueFrom, Observable } from 'rxjs';

import { EndPoint } from '../../../api-config';
import { HttpStore } from '../../http.store';
import { AbortControllersManager } from '../../store-helpers/abort-controllers-manager';

export type GetClientPresenceLocationsEngagementByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `postsSummary`
   * - `eventsSummary`</details>
   */
  expand?: string;
};
export type GetClientPresenceLocationsEngagementInsightsFacebookByLocationIdOpts = {
  FE_UNIQUE_ID?: string;

  startDate?: string;

  endDate?: string;

  type?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsEngagementInsightsInstagramByLocationIdOpts = {
  FE_UNIQUE_ID?: string;

  startDate?: string;

  endDate?: string;

  type?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdOpts = {
  FE_UNIQUE_ID?: string;

  startDate?: string;

  endDate?: string;

  type?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsFacebookByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If true, data will not be retrieved from cache
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `instagramLocation`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `metaAdAccounts`
   * - `locale`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `listings`
   * - `locationListingServicesToBeDeactivated`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type PatchClientPresenceLocationsFacebookSyncSettingsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsFacebookSyncSettingsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsFacebookUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsFacebookUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsFacebookTokenInitByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsFacebookTokenResponseOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Contains the Location's id
   */
  state: string;
  /**
   * Temporary code for request of token
   */
  code?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If true, data will not be retrieved from cache
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsFacebookTokenDisconnectByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsGoogleByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If true, location statistics are loaded
   */
  loadStatistics?: boolean;
  /**
   * Start date for statistics reports
   */
  statisticsStartDate?: string;
  /**
   * End date for statistics reports
   */
  statisticsEndDate?: string;
  /**
   * If true, location media items are loaded
   */
  loadMediaItems?: boolean;
  /**
   * If true, location attributes are loaded
   */
  loadAttributes?: boolean;
  /**
   * If true, location service types are loaded
   */
  loadServiceTypes?: boolean;
  /**
   * If true, location admins are loaded
   */
  loadAdmins?: boolean;
  /**
   * If true, will load keywords statistics
   */
  loadKeywordsStatistics?: boolean;
  /**
   * If true, data will not be retrieved from cache
   */
  noCache?: boolean;
  /**
   * Used for keywords statistics
   */
  nextPageToken?: string;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `statistics`
   * - `keywordsStatistics`
   * - `attributes`
   * - `serviceItems`
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locationAdmins`
   * - `locationState`
   * - `verifications`
   * - `locale`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `listings`
   * - `locationListingServicesToBeDeactivated`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type DeleteClientPresenceLocationsGoogleByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If true, GoogleLocation is deleted even if state is not by default eligible for deletion
   */
  forceDeletion?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsGoogleAttributesByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsGoogleAttributesByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsGoogleServicesByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsGoogleServicesByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsGoogleUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsGoogleUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsGoogleAdminsInviteByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsGoogleVerificationsCreateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Selected verification method
   * Allowed Values:
   * -   `ADDRESS`
   * -   `EMAIL`
   * -   `PHONE_CALL`
   * -   `SMS`
   *
   */
  method: string;

  email?: string;

  phoneNumber?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsGoogleVerificationsCompleteByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Id of initiated verification
   */
  verificationId: string;
  /**
   * Pincode for initiated verification
   */
  pincode?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsGoogleSyncSettingsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsGoogleSyncSettingsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsGoogleTokenInitByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsGoogleTokenResponseOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Contains the Location's id
   */
  state: string;
  /**
   * Temporary code for request of token
   */
  code?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `DISTANCE`
   * - `BUSINESS_NAME`
   * - `POSTAL_CODE`
   * - `CITY`
   * - `CATEGORIES`
   * - `OPEN_INFO_STATUS`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `DISTANCE`: Filter by the distance of the GoogleLocation from current Location's geo coordinates
   * - `BUSINESS_NAME`: Filter by company / doing business as name
   * - `PRIMARY_PHONE`: Filter by primary phone number in E.164 format (For example: "+441234567890")
   * - `COUNTRY_SHORT_CODE`: Filter by country shortCode, e.g. 'us'
   * - `STATE`: Filter by state, e.g. "CA"
   * - `CITY`: Filter by city
   * - `POSTAL_CODE`: Filter by postalCode
   * - `PLACE_ID`: Filter by GoogleLocations's Google Place ID, if it has been verified and is connected to/appears on Google Maps
   * - `CATEGORIES`: Filter by categories
   * - `LABELS`: Filter by labels
   * - `STORE_CODE`: Filter by external identifier, which must be unique inside a given account
   * - `OPEN_INFO_STATUS`: Filter by OpenInfo status - one of [`OPEN`, `CLOSED_TEMPORARILY`, `CLOSED_PERMANENTLY`]</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `statistics`
   * - `keywordsStatistics`
   * - `attributes`
   * - `serviceItems`
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locationAdmins`
   * - `locationState`
   * - `verifications`
   * - `locale`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `listings`
   * - `locationListingServicesToBeDeactivated`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type GetClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsGoogleTokenDisconnectByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceGooglePlacesAutocompleteOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * The string to search for
   */
  searchInput: string;
  /**
   * 2-letter code language, relevant to localize location names
   */
  languageCode: string;
  /**
   * 2-letter country code, for restricting search result
   */
  countryShortCode?: string;
  /**
   * The types to which the search is restricted. Types have to be separataed by comma and be maximum 5 of the following
   * - (regions)
   * - (cities)
   * - locality
   * - sublocality
   * - postal_code
   * - country
   * - administrative_area_level_1
   * - administrative_area_level_2
   * ,sublocality
   */
  types?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceGooglePlacesSearchOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * The string to search for
   */
  searchInput: string;
  /**
   * 2-letter code language, relevant to localize results
   */
  languageCode: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `DISTANCE`
   * - `GEOPOINT`
   * - `OPENNOW`
   * - `MINPRICE`
   * - `MAXPRICE`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `DISTANCE`: Defines the distance (in meters) within which to return place results. You may bias results to a specified circle by passing a location and a distance parameter. Doing so instructs the Places service to prefer showing results within that circle; results outside of the defined area may still be displayed.
   * The distance will automatically be clamped to a maximum value. Without passing a `GEOPOINT` filter, this is ignored
   * - `GEOPOINT`: GeoPoint as lat,lng string, e.g. `52.1,3.2`, without passing the `DISTANCE` filter, this is ignored
   * - `OPENNOW`: Restricts results to only those places within the specified range. Valid values range between 0 (most affordable) to 4 (most expensive), inclusive. The exact amount indicated by a specific value will vary from region to region - one of [`1`]
   * - `MINPRICE`: Restricts results to only those places within the specified range. Valid values range between 0 (most affordable) to 4 (most expensive), inclusive. The exact amount indicated by a specific value will vary from region to region - one of [`0`, `1`, `2`, `3`, `4`]
   * - `MAXPRICE`: Restricts results to only those places within the specified range. Valid values range between 0 (most affordable) to 4 (most expensive), inclusive. The exact amount indicated by a specific value will vary from region to region - one of [`0`, `1`, `2`, `3`, `4`]</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `serviceArea`</details>
   */
  expand?: string;
};
export type GetClientPresenceGooglePlacesByIdByGooglePlaceIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * 2-letter code language, relevant to localize results
   */
  languageCode: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `serviceArea`</details>
   */
  expand?: string;
};
export type GetClientPresenceGooglePlacesSearchByAddressOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * The string to search for
   */
  searchInput: string;
  /**
   * 2-letter code language, relevant to localize results
   */
  languageCode: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `DISTANCE`
   * - `GEOPOINT`
   * - `OPENNOW`
   * - `MINPRICE`
   * - `MAXPRICE`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `DISTANCE`: Defines the distance (in meters) within which to return place results. You may bias results to a specified circle by passing a location and a distance parameter. Doing so instructs the Places service to prefer showing results within that circle; results outside of the defined area may still be displayed.
   * The distance will automatically be clamped to a maximum value. Without passing a `GEOPOINT` filter, this is ignored
   * - `GEOPOINT`: GeoPoint as lat,lng string, e.g. `52.1,3.2`, without passing the `DISTANCE` filter, this is ignored
   * - `OPENNOW`: Restricts results to only those places within the specified range. Valid values range between 0 (most affordable) to 4 (most expensive), inclusive. The exact amount indicated by a specific value will vary from region to region - one of [`1`]
   * - `MINPRICE`: Restricts results to only those places within the specified range. Valid values range between 0 (most affordable) to 4 (most expensive), inclusive. The exact amount indicated by a specific value will vary from region to region - one of [`0`, `1`, `2`, `3`, `4`]
   * - `MAXPRICE`: Restricts results to only those places within the specified range. Valid values range between 0 (most affordable) to 4 (most expensive), inclusive. The exact amount indicated by a specific value will vary from region to region - one of [`0`, `1`, `2`, `3`, `4`]</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `serviceArea`</details>
   */
  expand?: string;
};
export type PatchClientPresenceLocationsInterfaceDataByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsInterfaceDataByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsListingsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * $ignoreSlowLoadingDirectories Indicates whether the retrieved listings are used for onboarding purposes
   */
  ignoreSlowLoadingDirectories?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsListingservicesByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsListingsUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsListingsUpdateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type DeleteClientPresenceLocationsListingsDeactivateByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsYextByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Whether to propose and save opening hours or not
   */
  proposeAndSaveOpeningHours?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type PatchClientPresenceLocationsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type PostClientPresenceLocationsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type GetClientPresenceLocationsSettingsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Whether to propose and save opening hours or not
   */
  proposeAndSaveOpeningHours?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type GetClientPresenceLocationsSummaryByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Whether to propose and save opening hours or not
   */
  proposeAndSaveOpeningHours?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type GetClientPresenceLocationsCompanyVerificationByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Whether to propose and save opening hours or not
   */
  proposeAndSaveOpeningHours?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type PatchClientPresenceLocationsCompanyVerificationByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsCompanyVerificationByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsLocalesByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Whether to propose and save opening hours or not
   */
  proposeAndSaveOpeningHours?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type GetClientPresenceLocationsResetTasksByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Whether to propose and save opening hours or not
   */
  proposeAndSaveOpeningHours?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type PostClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsIsFreeAccountByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * Whether to propose and save opening hours or not
   */
  proposeAndSaveOpeningHours?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   * </details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   * </details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `isOwnerUploaded`
   *     - `hasCorrectAspectRatio`
   *     - `scope`
   *     - `identifier`
   *     - `settings.uberall.createdDateTime`
   *     - `settings.uberall.externalId`
   *     - `settings.uberall.publicUrl`
   *     - `settings.uberall.toBeDeleted`
   *     - `settings.uberall.status`
   *     - `settings.google.createdDateTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publicUrl`
   *     - `settings.google.toBeDeleted`
   *     - `settings.google.status`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publicUrl`
   *     - `settings.facebook.toBeDeleted`
   *     - `settings.facebook.status`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publicUrl`
   *     - `settings.instagram.toBeDeleted`
   *     - `settings.instagram.status`
   *     - `settings.yext.createdDateTime`
   *     - `settings.yext.externalId`
   *     - `settings.yext.publicUrl`
   *     - `settings.yext.toBeDeleted`
   *     - `settings.yext.status`
   *     - `settings.toBeDeleted`
   *     - `settings.deletionCompletedOnAllListingServices`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `locale`
   * - `openingHours`
   * - `categories`
   * - `serviceAreas`
   *   - Allowed filter properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   *   - Allowed orderBy properties are:
   *     - `locationId`
   *     - `serviceAreaId`
   *     - `id`
   * - `keywords`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `listings`
   * - `website`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `seo`
   * - `locationListingServices`
   * - `locationListingServicesToBeDeactivated`
   * - `listingServices`
   * - `visibilityIndex`
   * - `settings`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `competitors`
   *   - Allowed filter properties are:
   *     - `source`: one of [`CUSTOMER_SELECTED`, `GOOGLE`]
   *   - Allowed orderBy properties are:
   *     - `REPUTATION`
   *     - `DISTANCE`
   *     - `VISIBILITY`
   *     - `VISIBILITY_AND_DISTANCE`
   * - `reputation`
   * - `setupSequenceCompletions`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `setupSequences`
   *   - Allowed filter properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   *   - Allowed orderBy properties are:
   *     - `type`
   *     - `id`
   *     - `setupSteps.name`
   *     - `setupSteps.setupSequenceId`
   *     - `setupSteps.isFinalStep`
   *     - `setupSteps.id`
   * - `posts`
   *   - Allowed filter properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   *   - Allowed orderBy properties are:
   *     - `title`
   *     - `startDate`
   *     - `endDate`
   *     - `type`
   *     - `status`
   *     - `createdExternally`
   *     - `content`
   *     - `locationId`
   *     - `scheduleAt`
   *     - `publishedAt`
   *     - `settings.google.languageCode`
   *     - `settings.google.callToAction.actionType`
   *     - `settings.google.callToAction.url`
   *     - `settings.google.error`
   *     - `settings.google.createdTime`
   *     - `settings.google.updatedTime`
   *     - `settings.google.externalId`
   *     - `settings.google.publishOnListingService`
   *     - `settings.google.status`
   *     - `settings.google.content`
   *     - `settings.google.permalinkUrl`
   *     - `settings.google.errorMessage`
   *     - `settings.google.publishedAt`
   *     - `settings.google.requireListingUpdate`
   *     - `settings.google.created`
   *     - `settings.google.updated`
   *     - `settings.facebook.views`
   *     - `settings.facebook.likes`
   *     - `settings.facebook.shares`
   *     - `settings.facebook.error`
   *     - `settings.facebook.createdTime`
   *     - `settings.facebook.updatedTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.publishOnListingService`
   *     - `settings.facebook.status`
   *     - `settings.facebook.content`
   *     - `settings.facebook.permalinkUrl`
   *     - `settings.facebook.errorMessage`
   *     - `settings.facebook.publishedAt`
   *     - `settings.facebook.requireListingUpdate`
   *     - `settings.instagram.error.type`
   *     - `settings.instagram.error.message`
   *     - `settings.instagram.error.code`
   *     - `settings.instagram.owner.id`
   *     - `settings.instagram.likes`
   *     - `settings.instagram.comments`
   *     - `settings.instagram.createdTime`
   *     - `settings.instagram.updatedTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.publishOnListingService`
   *     - `settings.instagram.status`
   *     - `settings.instagram.content`
   *     - `settings.instagram.permalinkUrl`
   *     - `settings.instagram.errorMessage`
   *     - `settings.instagram.publishedAt`
   *     - `settings.instagram.requireListingUpdate`
   *     - `settings.instagram.created`
   *     - `settings.instagram.updated`
   *     - `id`
   *     - `created`
   *     - `updated`
   *     - `mediaItems.postId`
   *     - `mediaItems.identifier`
   *     - `mediaItems.settings.facebook.createdDateTime`
   *     - `mediaItems.settings.facebook.externalId`
   *     - `mediaItems.settings.facebook.message`
   *     - `mediaItems.settings.facebook.status`
   *     - `mediaItems.settings.facebook.publicUrl`
   *     - `mediaItems.settings.instagram.createdDateTime`
   *     - `mediaItems.settings.instagram.externalId`
   *     - `mediaItems.settings.instagram.message`
   *     - `mediaItems.settings.instagram.status`
   *     - `mediaItems.settings.instagram.publicUrl`
   *     - `mediaItems.settings.downloadConfirmation.url`
   *     - `mediaItems.settings.downloadConfirmation.authorUsername`
   *     - `mediaItems.settings.downloadConfirmation.authorFullName`
   *     - `mediaItems.settings.removed`
   *     - `mediaItems.settings.isAIGenerated`
   *     - `mediaItems.uploadedToArgus`
   *     - `mediaItems.type`
   *     - `mediaItems.publicUrl`
   *     - `mediaItems.description`
   *     - `mediaItems.viewCount`
   *     - `mediaItems.id`
   *     - `mediaItems.created`
   *     - `mediaItems.updated`
   *     - `boostAdCreatives.objectStorySpec.instagramActorId`
   *     - `boostAdCreatives.objectStorySpec.linkData.name`
   *     - `boostAdCreatives.objectStorySpec.linkData.description`
   *     - `boostAdCreatives.objectStorySpec.linkData.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.picture`
   *     - `boostAdCreatives.objectStorySpec.linkData.message`
   *     - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   *     - `boostAdCreatives.objectStorySpec.pageId`
   *     - `boostAdCreatives.objectStorySpec.postExternalId`
   *     - `boostAdCreatives.objectStorySpec.callToActionType`
   *     - `boostAdCreatives.postId`
   *     - `boostAdCreatives.name`
   *     - `boostAdCreatives.externalId`
   *     - `boostAdCreatives.id`
   *     - `boostAdCreatives.created`
   *     - `boostAdCreatives.updated`
   * - `engagement`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `adAccount`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:
   * - `tasks`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type GetClientPresenceLocationsMediaItemsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `locationId`
   * - `isOwnerUploaded`
   * - `hasCorrectAspectRatio`
   * - `scope`
   * - `identifier`
   * - `settings.uberall.createdDateTime`
   * - `settings.uberall.externalId`
   * - `settings.uberall.publicUrl`
   * - `settings.uberall.toBeDeleted`
   * - `settings.uberall.status`
   * - `settings.google.createdDateTime`
   * - `settings.google.externalId`
   * - `settings.google.publicUrl`
   * - `settings.google.toBeDeleted`
   * - `settings.google.status`
   * - `settings.facebook.createdDateTime`
   * - `settings.facebook.externalId`
   * - `settings.facebook.publicUrl`
   * - `settings.facebook.toBeDeleted`
   * - `settings.facebook.status`
   * - `settings.instagram.createdDateTime`
   * - `settings.instagram.externalId`
   * - `settings.instagram.publicUrl`
   * - `settings.instagram.toBeDeleted`
   * - `settings.instagram.status`
   * - `settings.yext.createdDateTime`
   * - `settings.yext.externalId`
   * - `settings.yext.publicUrl`
   * - `settings.yext.toBeDeleted`
   * - `settings.yext.status`
   * - `settings.toBeDeleted`
   * - `settings.deletionCompletedOnAllListingServices`
   * - `type`
   * - `publicUrl`
   * - `description`
   * - `viewCount`
   * - `id`
   * - `created`
   * - `updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `locationId`
   * - `isOwnerUploaded`
   * - `hasCorrectAspectRatio`
   * - `scope`
   * - `identifier`
   * - `settings.uberall.createdDateTime`
   * - `settings.uberall.externalId`
   * - `settings.uberall.publicUrl`
   * - `settings.uberall.toBeDeleted`
   * - `settings.uberall.status`
   * - `settings.google.createdDateTime`
   * - `settings.google.externalId`
   * - `settings.google.publicUrl`
   * - `settings.google.toBeDeleted`
   * - `settings.google.status`
   * - `settings.facebook.createdDateTime`
   * - `settings.facebook.externalId`
   * - `settings.facebook.publicUrl`
   * - `settings.facebook.toBeDeleted`
   * - `settings.facebook.status`
   * - `settings.instagram.createdDateTime`
   * - `settings.instagram.externalId`
   * - `settings.instagram.publicUrl`
   * - `settings.instagram.toBeDeleted`
   * - `settings.instagram.status`
   * - `settings.yext.createdDateTime`
   * - `settings.yext.externalId`
   * - `settings.yext.publicUrl`
   * - `settings.yext.toBeDeleted`
   * - `settings.yext.status`
   * - `settings.toBeDeleted`
   * - `settings.deletionCompletedOnAllListingServices`
   * - `type`
   * - `publicUrl`
   * - `description`
   * - `viewCount`
   * - `id`
   * - `created`
   * - `updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `googleImportDetails`
   * - `mediaItemContent`</details>
   */
  expand?: string;
};
export type DeleteClientPresenceLocationsMediaItemsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsMediaItemsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsMediaItemsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsVisibilityByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceMediaItemsLocationByJwtOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If true, the image is adusted for its upload reqirements
   */
  adjustImageToRequirements?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceMediaItemsPostByJwtOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If true, the image is adusted for its upload reqirements
   */
  adjustImageToRequirements?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceMediaItemsVerificationByJwtOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If true, the image is adusted for its upload reqirements
   */
  adjustImageToRequirements?: boolean;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsPostsMediaItemsByPostIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `postId`
   * - `identifier`
   * - `settings.facebook.createdDateTime`
   * - `settings.facebook.externalId`
   * - `settings.facebook.message`
   * - `settings.facebook.status`
   * - `settings.facebook.publicUrl`
   * - `settings.instagram.createdDateTime`
   * - `settings.instagram.externalId`
   * - `settings.instagram.message`
   * - `settings.instagram.status`
   * - `settings.instagram.publicUrl`
   * - `settings.downloadConfirmation.url`
   * - `settings.downloadConfirmation.authorUsername`
   * - `settings.downloadConfirmation.authorFullName`
   * - `settings.removed`
   * - `settings.isAIGenerated`
   * - `uploadedToArgus`
   * - `type`
   * - `publicUrl`
   * - `description`
   * - `viewCount`
   * - `id`
   * - `created`
   * - `updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `postId`
   * - `identifier`
   * - `settings.facebook.createdDateTime`
   * - `settings.facebook.externalId`
   * - `settings.facebook.message`
   * - `settings.facebook.status`
   * - `settings.facebook.publicUrl`
   * - `settings.instagram.createdDateTime`
   * - `settings.instagram.externalId`
   * - `settings.instagram.message`
   * - `settings.instagram.status`
   * - `settings.instagram.publicUrl`
   * - `settings.downloadConfirmation.url`
   * - `settings.downloadConfirmation.authorUsername`
   * - `settings.downloadConfirmation.authorFullName`
   * - `settings.removed`
   * - `settings.isAIGenerated`
   * - `uploadedToArgus`
   * - `type`
   * - `publicUrl`
   * - `description`
   * - `viewCount`
   * - `id`
   * - `created`
   * - `updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItemContent`</details>
   */
  expand?: string;
};
export type PatchClientPresenceLocationsPostsMediaItemsByPostIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsPostsMediaItemsByPostIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsPostsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `title`
   * - `startDate`
   * - `endDate`
   * - `type`
   * - `status`
   * - `createdExternally`
   * - `content`
   * - `locationId`
   * - `scheduleAt`
   * - `publishedAt`
   * - `settings.google.languageCode`
   * - `settings.google.callToAction.actionType`
   * - `settings.google.callToAction.url`
   * - `settings.google.error`
   * - `settings.google.createdTime`
   * - `settings.google.updatedTime`
   * - `settings.google.externalId`
   * - `settings.google.publishOnListingService`
   * - `settings.google.status`
   * - `settings.google.content`
   * - `settings.google.permalinkUrl`
   * - `settings.google.errorMessage`
   * - `settings.google.publishedAt`
   * - `settings.google.requireListingUpdate`
   * - `settings.google.created`
   * - `settings.google.updated`
   * - `settings.facebook.views`
   * - `settings.facebook.likes`
   * - `settings.facebook.shares`
   * - `settings.facebook.error`
   * - `settings.facebook.createdTime`
   * - `settings.facebook.updatedTime`
   * - `settings.facebook.externalId`
   * - `settings.facebook.publishOnListingService`
   * - `settings.facebook.status`
   * - `settings.facebook.content`
   * - `settings.facebook.permalinkUrl`
   * - `settings.facebook.errorMessage`
   * - `settings.facebook.publishedAt`
   * - `settings.facebook.requireListingUpdate`
   * - `settings.instagram.error.type`
   * - `settings.instagram.error.message`
   * - `settings.instagram.error.code`
   * - `settings.instagram.owner.id`
   * - `settings.instagram.likes`
   * - `settings.instagram.comments`
   * - `settings.instagram.createdTime`
   * - `settings.instagram.updatedTime`
   * - `settings.instagram.externalId`
   * - `settings.instagram.publishOnListingService`
   * - `settings.instagram.status`
   * - `settings.instagram.content`
   * - `settings.instagram.permalinkUrl`
   * - `settings.instagram.errorMessage`
   * - `settings.instagram.publishedAt`
   * - `settings.instagram.requireListingUpdate`
   * - `settings.instagram.created`
   * - `settings.instagram.updated`
   * - `id`
   * - `created`
   * - `updated`
   * - `mediaItems.postId`
   * - `mediaItems.identifier`
   * - `mediaItems.settings.facebook.createdDateTime`
   * - `mediaItems.settings.facebook.externalId`
   * - `mediaItems.settings.facebook.message`
   * - `mediaItems.settings.facebook.status`
   * - `mediaItems.settings.facebook.publicUrl`
   * - `mediaItems.settings.instagram.createdDateTime`
   * - `mediaItems.settings.instagram.externalId`
   * - `mediaItems.settings.instagram.message`
   * - `mediaItems.settings.instagram.status`
   * - `mediaItems.settings.instagram.publicUrl`
   * - `mediaItems.settings.downloadConfirmation.url`
   * - `mediaItems.settings.downloadConfirmation.authorUsername`
   * - `mediaItems.settings.downloadConfirmation.authorFullName`
   * - `mediaItems.settings.removed`
   * - `mediaItems.settings.isAIGenerated`
   * - `mediaItems.uploadedToArgus`
   * - `mediaItems.type`
   * - `mediaItems.publicUrl`
   * - `mediaItems.description`
   * - `mediaItems.viewCount`
   * - `mediaItems.id`
   * - `mediaItems.created`
   * - `mediaItems.updated`
   * - `boostAdCreatives.objectStorySpec.instagramActorId`
   * - `boostAdCreatives.objectStorySpec.linkData.name`
   * - `boostAdCreatives.objectStorySpec.linkData.description`
   * - `boostAdCreatives.objectStorySpec.linkData.link`
   * - `boostAdCreatives.objectStorySpec.linkData.picture`
   * - `boostAdCreatives.objectStorySpec.linkData.message`
   * - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   * - `boostAdCreatives.objectStorySpec.pageId`
   * - `boostAdCreatives.objectStorySpec.postExternalId`
   * - `boostAdCreatives.objectStorySpec.callToActionType`
   * - `boostAdCreatives.postId`
   * - `boostAdCreatives.name`
   * - `boostAdCreatives.externalId`
   * - `boostAdCreatives.id`
   * - `boostAdCreatives.created`
   * - `boostAdCreatives.updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `title`
   * - `startDate`
   * - `endDate`
   * - `type`
   * - `status`
   * - `createdExternally`
   * - `content`
   * - `locationId`
   * - `scheduleAt`
   * - `publishedAt`
   * - `settings.google.languageCode`
   * - `settings.google.callToAction.actionType`
   * - `settings.google.callToAction.url`
   * - `settings.google.error`
   * - `settings.google.createdTime`
   * - `settings.google.updatedTime`
   * - `settings.google.externalId`
   * - `settings.google.publishOnListingService`
   * - `settings.google.status`
   * - `settings.google.content`
   * - `settings.google.permalinkUrl`
   * - `settings.google.errorMessage`
   * - `settings.google.publishedAt`
   * - `settings.google.requireListingUpdate`
   * - `settings.google.created`
   * - `settings.google.updated`
   * - `settings.facebook.views`
   * - `settings.facebook.likes`
   * - `settings.facebook.shares`
   * - `settings.facebook.error`
   * - `settings.facebook.createdTime`
   * - `settings.facebook.updatedTime`
   * - `settings.facebook.externalId`
   * - `settings.facebook.publishOnListingService`
   * - `settings.facebook.status`
   * - `settings.facebook.content`
   * - `settings.facebook.permalinkUrl`
   * - `settings.facebook.errorMessage`
   * - `settings.facebook.publishedAt`
   * - `settings.facebook.requireListingUpdate`
   * - `settings.instagram.error.type`
   * - `settings.instagram.error.message`
   * - `settings.instagram.error.code`
   * - `settings.instagram.owner.id`
   * - `settings.instagram.likes`
   * - `settings.instagram.comments`
   * - `settings.instagram.createdTime`
   * - `settings.instagram.updatedTime`
   * - `settings.instagram.externalId`
   * - `settings.instagram.publishOnListingService`
   * - `settings.instagram.status`
   * - `settings.instagram.content`
   * - `settings.instagram.permalinkUrl`
   * - `settings.instagram.errorMessage`
   * - `settings.instagram.publishedAt`
   * - `settings.instagram.requireListingUpdate`
   * - `settings.instagram.created`
   * - `settings.instagram.updated`
   * - `id`
   * - `created`
   * - `updated`
   * - `mediaItems.postId`
   * - `mediaItems.identifier`
   * - `mediaItems.settings.facebook.createdDateTime`
   * - `mediaItems.settings.facebook.externalId`
   * - `mediaItems.settings.facebook.message`
   * - `mediaItems.settings.facebook.status`
   * - `mediaItems.settings.facebook.publicUrl`
   * - `mediaItems.settings.instagram.createdDateTime`
   * - `mediaItems.settings.instagram.externalId`
   * - `mediaItems.settings.instagram.message`
   * - `mediaItems.settings.instagram.status`
   * - `mediaItems.settings.instagram.publicUrl`
   * - `mediaItems.settings.downloadConfirmation.url`
   * - `mediaItems.settings.downloadConfirmation.authorUsername`
   * - `mediaItems.settings.downloadConfirmation.authorFullName`
   * - `mediaItems.settings.removed`
   * - `mediaItems.settings.isAIGenerated`
   * - `mediaItems.uploadedToArgus`
   * - `mediaItems.type`
   * - `mediaItems.publicUrl`
   * - `mediaItems.description`
   * - `mediaItems.viewCount`
   * - `mediaItems.id`
   * - `mediaItems.created`
   * - `mediaItems.updated`
   * - `boostAdCreatives.objectStorySpec.instagramActorId`
   * - `boostAdCreatives.objectStorySpec.linkData.name`
   * - `boostAdCreatives.objectStorySpec.linkData.description`
   * - `boostAdCreatives.objectStorySpec.linkData.link`
   * - `boostAdCreatives.objectStorySpec.linkData.picture`
   * - `boostAdCreatives.objectStorySpec.linkData.message`
   * - `boostAdCreatives.objectStorySpec.linkData.childAttachments`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.type`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appDestination`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.appLink`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.application`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.link`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.linkCaption`
   * - `boostAdCreatives.objectStorySpec.linkData.callToAction.value.page`
   * - `boostAdCreatives.objectStorySpec.pageId`
   * - `boostAdCreatives.objectStorySpec.postExternalId`
   * - `boostAdCreatives.objectStorySpec.callToActionType`
   * - `boostAdCreatives.postId`
   * - `boostAdCreatives.name`
   * - `boostAdCreatives.externalId`
   * - `boostAdCreatives.id`
   * - `boostAdCreatives.created`
   * - `boostAdCreatives.updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `postId`
   *     - `identifier`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.message`
   *     - `settings.facebook.status`
   *     - `settings.facebook.publicUrl`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.message`
   *     - `settings.instagram.status`
   *     - `settings.instagram.publicUrl`
   *     - `settings.downloadConfirmation.url`
   *     - `settings.downloadConfirmation.authorUsername`
   *     - `settings.downloadConfirmation.authorFullName`
   *     - `settings.removed`
   *     - `settings.isAIGenerated`
   *     - `uploadedToArgus`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `postId`
   *     - `identifier`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.message`
   *     - `settings.facebook.status`
   *     - `settings.facebook.publicUrl`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.message`
   *     - `settings.instagram.status`
   *     - `settings.instagram.publicUrl`
   *     - `settings.downloadConfirmation.url`
   *     - `settings.downloadConfirmation.authorUsername`
   *     - `settings.downloadConfirmation.authorFullName`
   *     - `settings.removed`
   *     - `settings.isAIGenerated`
   *     - `uploadedToArgus`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `facebookPost`
   * - `instagramPost`
   * - `boostAdCreatives`
   *   - Allowed filter properties are:
   *     - `objectStorySpec.instagramActorId`
   *     - `objectStorySpec.linkData.name`
   *     - `objectStorySpec.linkData.description`
   *     - `objectStorySpec.linkData.link`
   *     - `objectStorySpec.linkData.picture`
   *     - `objectStorySpec.linkData.message`
   *     - `objectStorySpec.linkData.childAttachments`
   *     - `objectStorySpec.linkData.callToAction.type`
   *     - `objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `objectStorySpec.linkData.callToAction.value.appLink`
   *     - `objectStorySpec.linkData.callToAction.value.application`
   *     - `objectStorySpec.linkData.callToAction.value.link`
   *     - `objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `objectStorySpec.linkData.callToAction.value.page`
   *     - `objectStorySpec.pageId`
   *     - `objectStorySpec.postExternalId`
   *     - `objectStorySpec.callToActionType`
   *     - `postId`
   *     - `name`
   *     - `externalId`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `objectStorySpec.instagramActorId`
   *     - `objectStorySpec.linkData.name`
   *     - `objectStorySpec.linkData.description`
   *     - `objectStorySpec.linkData.link`
   *     - `objectStorySpec.linkData.picture`
   *     - `objectStorySpec.linkData.message`
   *     - `objectStorySpec.linkData.childAttachments`
   *     - `objectStorySpec.linkData.callToAction.type`
   *     - `objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `objectStorySpec.linkData.callToAction.value.appLink`
   *     - `objectStorySpec.linkData.callToAction.value.application`
   *     - `objectStorySpec.linkData.callToAction.value.link`
   *     - `objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `objectStorySpec.linkData.callToAction.value.page`
   *     - `objectStorySpec.pageId`
   *     - `objectStorySpec.postExternalId`
   *     - `objectStorySpec.callToActionType`
   *     - `postId`
   *     - `name`
   *     - `externalId`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `shortUrls`
   * - `comments`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type PatchClientPresenceLocationsPostsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsPostsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsPostsByPostIdByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
  /**
   * Number of results to be skipped / offsetted
   */
  skip?: number;
  /**
   * The number of results to be returned
   */
  top?: number;
  /**
   * Definition of orderBy follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <direction>?, <property> <direction>? ... ]?`
   *
   * **Examples:**
   * - `priority asc, creationDate desc, price?`
   * Direction one of: [`asc`, `desc`]
   * </details>
   *
   * <details><summary>Allowed orderBy properties:</summary>
   *
   *
   * - `type`
   * - `status`
   * - `createdExternally`
   * - `content`
   * - `locationId`
   * - `scheduleAt`
   * - `publishedAt`
   * - `settings.google.languageCode`
   * - `settings.google.callToAction.actionType`
   * - `settings.google.callToAction.url`
   * - `settings.google.error`
   * - `settings.google.createdTime`
   * - `settings.google.updatedTime`
   * - `settings.google.externalId`
   * - `settings.google.publishOnListingService`
   * - `settings.google.status`
   * - `settings.google.content`
   * - `settings.google.permalinkUrl`
   * - `settings.google.errorMessage`
   * - `settings.google.publishedAt`
   * - `settings.google.requireListingUpdate`
   * - `settings.google.created`
   * - `settings.google.updated`
   * - `settings.facebook.views`
   * - `settings.facebook.likes`
   * - `settings.facebook.shares`
   * - `settings.facebook.error`
   * - `settings.facebook.createdTime`
   * - `settings.facebook.updatedTime`
   * - `settings.facebook.externalId`
   * - `settings.facebook.publishOnListingService`
   * - `settings.facebook.status`
   * - `settings.facebook.content`
   * - `settings.facebook.permalinkUrl`
   * - `settings.facebook.errorMessage`
   * - `settings.facebook.publishedAt`
   * - `settings.facebook.requireListingUpdate`
   * - `settings.instagram.error.type`
   * - `settings.instagram.error.message`
   * - `settings.instagram.error.code`
   * - `settings.instagram.owner.id`
   * - `settings.instagram.likes`
   * - `settings.instagram.comments`
   * - `settings.instagram.createdTime`
   * - `settings.instagram.updatedTime`
   * - `settings.instagram.externalId`
   * - `settings.instagram.publishOnListingService`
   * - `settings.instagram.status`
   * - `settings.instagram.content`
   * - `settings.instagram.permalinkUrl`
   * - `settings.instagram.errorMessage`
   * - `settings.instagram.publishedAt`
   * - `settings.instagram.requireListingUpdate`
   * - `settings.instagram.created`
   * - `settings.instagram.updated`
   * - `id`
   * - `created`
   * - `updated`</details>
   */
  orderBy?: string;
  /**
   * Definition of filters follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> <operator> <value> [ <and|or> <property> <operator> <value> ... ]`
   * Value can be either `numeric`, (e.g. 10 or 10.4231) or `string` (e.g. 'active') or a JSON `array` format (e.g. ['ACTIVE','DELETED']) or `null` (null or 'null')
   *
   * **Examples:**
   * - `price lt 10`
   * - `price ge 10.8 and price le 20 or categoryId eq 12`
   * - `city eq 'Berlin'`
   * - `city in ['Berlin','Paris']`
   * Strings have to be put in quotes `'` If values contain single quotes, they need to be escaped. E.g. `location eq 'llocnou d\'en fenollet'`
   * Supported operators: `lt` lower then, `gt` greater then, `le` lower equal, `ge` greater equal, `eq` equal, `ne` not equal, `in` in and `bw` between.
   * `null`-value supports only `eq` and `ne`, `array`-value supports only `in` and `bw` operators.
   * </details>
   *
   * <details><summary>Allowed filter properties:</summary>
   *
   *
   * - `type`
   * - `status`
   * - `createdExternally`
   * - `content`
   * - `locationId`
   * - `scheduleAt`
   * - `publishedAt`
   * - `settings.google.languageCode`
   * - `settings.google.callToAction.actionType`
   * - `settings.google.callToAction.url`
   * - `settings.google.error`
   * - `settings.google.createdTime`
   * - `settings.google.updatedTime`
   * - `settings.google.externalId`
   * - `settings.google.publishOnListingService`
   * - `settings.google.status`
   * - `settings.google.content`
   * - `settings.google.permalinkUrl`
   * - `settings.google.errorMessage`
   * - `settings.google.publishedAt`
   * - `settings.google.requireListingUpdate`
   * - `settings.google.created`
   * - `settings.google.updated`
   * - `settings.facebook.views`
   * - `settings.facebook.likes`
   * - `settings.facebook.shares`
   * - `settings.facebook.error`
   * - `settings.facebook.createdTime`
   * - `settings.facebook.updatedTime`
   * - `settings.facebook.externalId`
   * - `settings.facebook.publishOnListingService`
   * - `settings.facebook.status`
   * - `settings.facebook.content`
   * - `settings.facebook.permalinkUrl`
   * - `settings.facebook.errorMessage`
   * - `settings.facebook.publishedAt`
   * - `settings.facebook.requireListingUpdate`
   * - `settings.instagram.error.type`
   * - `settings.instagram.error.message`
   * - `settings.instagram.error.code`
   * - `settings.instagram.owner.id`
   * - `settings.instagram.likes`
   * - `settings.instagram.comments`
   * - `settings.instagram.createdTime`
   * - `settings.instagram.updatedTime`
   * - `settings.instagram.externalId`
   * - `settings.instagram.publishOnListingService`
   * - `settings.instagram.status`
   * - `settings.instagram.content`
   * - `settings.instagram.permalinkUrl`
   * - `settings.instagram.errorMessage`
   * - `settings.instagram.publishedAt`
   * - `settings.instagram.requireListingUpdate`
   * - `settings.instagram.created`
   * - `settings.instagram.updated`
   * - `id`
   * - `created`
   * - `updated`</details>
   */
  filters?: string;
  /**
   * Definition of expanding options (properties to be loaded alongside with entity) follwing the syntax:
   * <details><summary>Definitions and examples:</summary>
   *
   * `<property> (<expandDefinitions>)?, <property> (<expandDefinitions)? ... ]`
   * `<expandDefinitions>` is defined as:
   * `<expandDefinition>,<expandDefinition>, ...`
   * `<expandDefinition>` is defined as:
   * `<filterDefinitions>` or `<orderByDefinitions>` or `<topDefinition>` or `<skipDefinition>` or `<expandDefinition>`
   *
   * *Examples:*
   * - `openingHours, competitors`
   * - `openingHours, competitors(filters=type eq 'GOOGLE';orderBy=KWS desc;top=10;skip=20)`
   * - `projects(expand=business(expand=locations(expand=website)))`
   * </details>
   *
   * <details><summary>Allowed expand properties:</summary>
   *
   *
   * - `mediaItems`
   *   - Allowed filter properties are:
   *     - `postId`
   *     - `identifier`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.message`
   *     - `settings.facebook.status`
   *     - `settings.facebook.publicUrl`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.message`
   *     - `settings.instagram.status`
   *     - `settings.instagram.publicUrl`
   *     - `settings.downloadConfirmation.url`
   *     - `settings.downloadConfirmation.authorUsername`
   *     - `settings.downloadConfirmation.authorFullName`
   *     - `settings.removed`
   *     - `settings.isAIGenerated`
   *     - `uploadedToArgus`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `postId`
   *     - `identifier`
   *     - `settings.facebook.createdDateTime`
   *     - `settings.facebook.externalId`
   *     - `settings.facebook.message`
   *     - `settings.facebook.status`
   *     - `settings.facebook.publicUrl`
   *     - `settings.instagram.createdDateTime`
   *     - `settings.instagram.externalId`
   *     - `settings.instagram.message`
   *     - `settings.instagram.status`
   *     - `settings.instagram.publicUrl`
   *     - `settings.downloadConfirmation.url`
   *     - `settings.downloadConfirmation.authorUsername`
   *     - `settings.downloadConfirmation.authorFullName`
   *     - `settings.removed`
   *     - `settings.isAIGenerated`
   *     - `uploadedToArgus`
   *     - `type`
   *     - `publicUrl`
   *     - `description`
   *     - `viewCount`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `facebookPost`
   * - `instagramPost`
   * - `boostAdCreatives`
   *   - Allowed filter properties are:
   *     - `objectStorySpec.instagramActorId`
   *     - `objectStorySpec.linkData.name`
   *     - `objectStorySpec.linkData.description`
   *     - `objectStorySpec.linkData.link`
   *     - `objectStorySpec.linkData.picture`
   *     - `objectStorySpec.linkData.message`
   *     - `objectStorySpec.linkData.childAttachments`
   *     - `objectStorySpec.linkData.callToAction.type`
   *     - `objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `objectStorySpec.linkData.callToAction.value.appLink`
   *     - `objectStorySpec.linkData.callToAction.value.application`
   *     - `objectStorySpec.linkData.callToAction.value.link`
   *     - `objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `objectStorySpec.linkData.callToAction.value.page`
   *     - `objectStorySpec.pageId`
   *     - `objectStorySpec.postExternalId`
   *     - `objectStorySpec.callToActionType`
   *     - `postId`
   *     - `name`
   *     - `externalId`
   *     - `id`
   *     - `created`
   *     - `updated`
   *   - Allowed orderBy properties are:
   *     - `objectStorySpec.instagramActorId`
   *     - `objectStorySpec.linkData.name`
   *     - `objectStorySpec.linkData.description`
   *     - `objectStorySpec.linkData.link`
   *     - `objectStorySpec.linkData.picture`
   *     - `objectStorySpec.linkData.message`
   *     - `objectStorySpec.linkData.childAttachments`
   *     - `objectStorySpec.linkData.callToAction.type`
   *     - `objectStorySpec.linkData.callToAction.value.appDestination`
   *     - `objectStorySpec.linkData.callToAction.value.appLink`
   *     - `objectStorySpec.linkData.callToAction.value.application`
   *     - `objectStorySpec.linkData.callToAction.value.link`
   *     - `objectStorySpec.linkData.callToAction.value.linkCaption`
   *     - `objectStorySpec.linkData.callToAction.value.page`
   *     - `objectStorySpec.pageId`
   *     - `objectStorySpec.postExternalId`
   *     - `objectStorySpec.callToActionType`
   *     - `postId`
   *     - `name`
   *     - `externalId`
   *     - `id`
   *     - `created`
   *     - `updated`
   * - `shortUrls`
   * - `comments`
   *   - Allowed filter properties are:
   *   - Allowed orderBy properties are:</details>
   */
  expand?: string;
};
export type DeleteClientPresenceLocationsPostsByPostIdByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsPostsCommentsByPostIdOpts = {
  /**
   * The Parent Social Media Entity ID - (a Post or Event)
   */
  parenEntityId?: number;
  /**
   * The social media platform, if it is not provided, comments forall social media platforms are returned
   * Allowed Values:
   * -   `FACEBOOK`
   * -   `INSTAGRAM`
   *
   */
  socialMediaSourceType?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PutClientPresenceLocationsPostsPublishByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PutClientPresenceLocationsPostsEditByLocationIdOpts = {
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsPostsGenerateInstructionByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsPostsGenerateInstructionByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsPostsCompetitorsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * The number Posts Variants to be generated based on Competitors' Posts
   */
  numberOfPostsToGenerate?: number;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * The number Posts Variants to be generated based on Competitors' Posts
   */
  numberOfPostsToGenerate?: number;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsPostsGenerateEventInstructionByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsCommentByLocationIdOpts = {
  /**
   * The social media platform, if it is not provided, comments forall social media platforms are returned
   * Allowed Values:
   * -   `FACEBOOK`
   * -   `INSTAGRAM`
   *
   */
  socialMediaSourceType: string;
  /**
   * The externalId of the SocialMediaComment from the listing platform
   */
  externalId: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsCommentByLocationIdOpts = {
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsCommentByLocationIdOpts = {
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type DeleteClientPresenceLocationsCommentByLocationIdOpts = {
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsCommentReactionByLocationIdOpts = {
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type DeleteClientPresenceLocationsCommentReactionByLocationIdOpts = {
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsCommentAiReplyByLocationIdOpts = {
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsCommentAiReplyByLocationIdOpts = {
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsUberallByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PatchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type PostClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};
export type GetClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts = {
  FE_UNIQUE_ID?: string;
  /**
   * If set to true, no EntityRegistry Argus Caching will be used
   */
  noCache?: boolean;
};

export class PresenceStore extends HttpStore {
  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsEngagementByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Retrieve Location Posts
   */

  /**
   * Retrieves engagement summary
   * Retrieve Location Posts
   */
  getClientPresenceLocationsEngagementByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsEngagementByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<EngagementSummaryResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/engagement`), queryParams, signal);
  }

  static getClientPresenceLocationsEngagementByLocationIdThunk = createAsyncThunk<
    EngagementSummaryResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsEngagementByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Retrieves engagement summary
     * Retrieve Location Posts
     */
    'getClientPresenceLocationsEngagementByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsEngagementByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsEngagementByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsEngagementByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsEngagementByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsEngagementByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsEngagementByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/engagement',
  );
  static getClientPresenceLocationsEngagementByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/engagement(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsEngagementInsightsFacebookByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns Facebook Insights: likes count, daily follows/unfollows,
   * daily organic/paid reach, number of likes by city/country
   * reach by age and gender
   *
   *
   *
   *
   *
   *
   * @throws \DateMalformedStringException
   */

  /**
   * Retrieves facebook social media insights
   * Returns Facebook Insights: likes count, daily follows/unfollows,
   * daily organic/paid reach, number of likes by city/country
   * reach by age and gender
   *
   *
   *
   *
   *
   *
   * @throws \DateMalformedStringException
   */
  getClientPresenceLocationsEngagementInsightsFacebookByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsEngagementInsightsFacebookByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<SocialMediaInsightsResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/engagement/insights/facebook`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsEngagementInsightsFacebookByLocationIdThunk = createAsyncThunk<
    SocialMediaInsightsResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsEngagementInsightsFacebookByLocationIdOpts },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * Retrieves facebook social media insights
     * Returns Facebook Insights: likes count, daily follows/unfollows,
     * daily organic/paid reach, number of likes by city/country
     * reach by age and gender
     *
     *
     *
     *
     *
     *
     * @throws \DateMalformedStringException
     */
    'getClientPresenceLocationsEngagementInsightsFacebookByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsEngagementInsightsFacebookByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsEngagementInsightsFacebookByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsEngagementInsightsFacebookByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsEngagementInsightsFacebookByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsEngagementInsightsFacebookByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsEngagementInsightsFacebookByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/engagement/insights/facebook',
  );
  static getClientPresenceLocationsEngagementInsightsFacebookByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/engagement/insights/facebook(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsEngagementInsightsInstagramByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns Instagram insights: followers count, comments, replies,
   * daily views, reach, impressions
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \DateMalformedStringException
   */

  /**
   * Retrieves facebook social media insights
   * Returns Instagram insights: followers count, comments, replies,
   * daily views, reach, impressions
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \DateMalformedStringException
   */
  getClientPresenceLocationsEngagementInsightsInstagramByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsEngagementInsightsInstagramByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<SocialMediaInsightsResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/engagement/insights/instagram`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsEngagementInsightsInstagramByLocationIdThunk = createAsyncThunk<
    SocialMediaInsightsResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsEngagementInsightsInstagramByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Retrieves facebook social media insights
     * Returns Instagram insights: followers count, comments, replies,
     * daily views, reach, impressions
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     * @throws \DateMalformedStringException
     */
    'getClientPresenceLocationsEngagementInsightsInstagramByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsEngagementInsightsInstagramByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsEngagementInsightsInstagramByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsEngagementInsightsInstagramByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsEngagementInsightsInstagramByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsEngagementInsightsInstagramByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsEngagementInsightsInstagramByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/engagement/insights/instagram',
  );
  static getClientPresenceLocationsEngagementInsightsInstagramByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/engagement/insights/instagram(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns potential audience for the ad account
   */

  /**
   * Get potential audience for ad account
   * Returns potential audience for the ad account
   */
  postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationId(
    locationId: number,
    requestBody: SocialMediaInsightsRequestDto,
    queryParams: PostClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<SocialMediaInsightsResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/engagement/insights/potentialAudience`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdThunk = createAsyncThunk<
    SocialMediaInsightsResponseDto,
    {
      locationId: number;
      requestBody: SocialMediaInsightsRequestDto;
      queryParams: PostClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Get potential audience for ad account
     * Returns potential audience for the ad account
     */
    'postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: SocialMediaInsightsRequestDto;
        queryParams: PostClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/engagement/insights/potentialAudience',
  );
  static postClientPresenceLocationsEngagementInsightsPotentialAudienceByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/engagement/insights/potentialAudience(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsFacebookByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get Facebook Location Details
   */

  /**
   * Facebook Location Details
   * Get Facebook Location Details
   */
  getClientPresenceLocationsFacebookByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsFacebookByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<FacebookLocationGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/facebook`), queryParams, signal);
  }

  static getClientPresenceLocationsFacebookByLocationIdThunk = createAsyncThunk<
    FacebookLocationGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsFacebookByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * Facebook Location Details
     * Get Facebook Location Details
     */
    'getClientPresenceLocationsFacebookByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsFacebookByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsFacebookByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsFacebookByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsFacebookByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsFacebookByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsFacebookByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/facebook',
  );
  static getClientPresenceLocationsFacebookByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsFacebookSyncSettingsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Facebook Location Connection Sync Settings
   */

  /**
   * Update GoogleLocation Sync Settings
   * Update Facebook Location Connection Sync Settings
   */
  patchClientPresenceLocationsFacebookSyncSettingsByLocationId(
    locationId: number,
    requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto,
    queryParams: PatchClientPresenceLocationsFacebookSyncSettingsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationListingServiceConnectionSyncSettingsUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/facebook/syncSettings`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsFacebookSyncSettingsByLocationIdThunk = createAsyncThunk<
    LocationListingServiceConnectionSyncSettingsUpdateResponseDto,
    {
      locationId: number;
      requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto;
      queryParams: PatchClientPresenceLocationsFacebookSyncSettingsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | MethodNotAllowedException;
    }
  >(
    /**
     * Update GoogleLocation Sync Settings
     * Update Facebook Location Connection Sync Settings
     */
    'patchClientPresenceLocationsFacebookSyncSettingsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto;
        queryParams: PatchClientPresenceLocationsFacebookSyncSettingsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsFacebookSyncSettingsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsFacebookSyncSettingsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsFacebookSyncSettingsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsFacebookSyncSettingsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsFacebookSyncSettingsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/facebook/syncSettings',
  );
  static patchClientPresenceLocationsFacebookSyncSettingsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook/syncSettings(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsFacebookSyncSettingsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Facebook Location Connection Sync Settings
   */

  /**
   * Update GoogleLocation Sync Settings
   * Update Facebook Location Connection Sync Settings
   */
  postClientPresenceLocationsFacebookSyncSettingsByLocationId(
    locationId: number,
    requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto,
    queryParams: PostClientPresenceLocationsFacebookSyncSettingsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<LocationListingServiceConnectionSyncSettingsUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/facebook/syncSettings`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsFacebookSyncSettingsByLocationIdThunk = createAsyncThunk<
    LocationListingServiceConnectionSyncSettingsUpdateResponseDto,
    {
      locationId: number;
      requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto;
      queryParams: PostClientPresenceLocationsFacebookSyncSettingsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | MethodNotAllowedException;
    }
  >(
    /**
     * Update GoogleLocation Sync Settings
     * Update Facebook Location Connection Sync Settings
     */
    'postClientPresenceLocationsFacebookSyncSettingsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto;
        queryParams: PostClientPresenceLocationsFacebookSyncSettingsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsFacebookSyncSettingsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsFacebookSyncSettingsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsFacebookSyncSettingsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsFacebookSyncSettingsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsFacebookSyncSettingsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/facebook/syncSettings',
  );
  static postClientPresenceLocationsFacebookSyncSettingsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook/syncSettings(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsFacebookUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates Facebook Location Business Data
   */

  /**
   * Publish Facebook Location
   * Updates Facebook Location Business Data
   */
  patchClientPresenceLocationsFacebookUpdateByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: PatchClientPresenceLocationsFacebookUpdateByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<FacebookLocationUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/facebook/update`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsFacebookUpdateByLocationIdThunk = createAsyncThunk<
    FacebookLocationUpdateResponseDto,
    { locationId: number; requestBody: null; queryParams: PatchClientPresenceLocationsFacebookUpdateByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Publish Facebook Location
     * Updates Facebook Location Business Data
     */
    'patchClientPresenceLocationsFacebookUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: null;
        queryParams: PatchClientPresenceLocationsFacebookUpdateByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsFacebookUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsFacebookUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsFacebookUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsFacebookUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsFacebookUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/facebook/update',
  );
  static patchClientPresenceLocationsFacebookUpdateByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsFacebookUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates Facebook Location Business Data
   */

  /**
   * Publish Facebook Location
   * Updates Facebook Location Business Data
   */
  postClientPresenceLocationsFacebookUpdateByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: PostClientPresenceLocationsFacebookUpdateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<FacebookLocationUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/facebook/update`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsFacebookUpdateByLocationIdThunk = createAsyncThunk<
    FacebookLocationUpdateResponseDto,
    {
      locationId: number;
      requestBody: null;
      queryParams: PostClientPresenceLocationsFacebookUpdateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Publish Facebook Location
     * Updates Facebook Location Business Data
     */
    'postClientPresenceLocationsFacebookUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: null;
        queryParams: PostClientPresenceLocationsFacebookUpdateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsFacebookUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsFacebookUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsFacebookUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsFacebookUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsFacebookUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/facebook/update',
  );
  static postClientPresenceLocationsFacebookUpdateByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsFacebookTokenInitByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Init connection to Facebook
   * - will provide the screens for Facebook login and permissions
   */

  /**
   * FacebookLocation Token Connect Init
   * Init connection to Facebook
   * - will provide the screens for Facebook login and permissions
   */
  getClientPresenceLocationsFacebookTokenInitByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsFacebookTokenInitByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<any> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/facebook/token/init`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsFacebookTokenInitByLocationIdThunk = createAsyncThunk<
    any,
    { locationId: number; queryParams: GetClientPresenceLocationsFacebookTokenInitByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * FacebookLocation Token Connect Init
     * Init connection to Facebook
     * - will provide the screens for Facebook login and permissions
     */
    'getClientPresenceLocationsFacebookTokenInitByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsFacebookTokenInitByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsFacebookTokenInitByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsFacebookTokenInitByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsFacebookTokenInitByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsFacebookTokenInitByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsFacebookTokenInitByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/facebook/token/init',
  );
  static getClientPresenceLocationsFacebookTokenInitByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook/token/init(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsFacebookTokenResponseAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * INIT (above) will redirect to this API and will provide the token for the connected Facebook account
   * (at this point in time the Facebook page is not connected to rC)
   */

  /**
   * FacebookLocation Token Connect Response
   * INIT (above) will redirect to this API and will provide the token for the connected Facebook account
   * (at this point in time the Facebook page is not connected to rC)
   */
  getClientPresenceLocationsFacebookTokenResponse(
    queryParams: GetClientPresenceLocationsFacebookTokenResponseOpts,
    signal?: AbortSignal,
  ): Observable<any> {
    return this.get(new EndPoint('/app/api/client/presence/locations/facebook/token/response'), queryParams, signal);
  }

  static getClientPresenceLocationsFacebookTokenResponseThunk = createAsyncThunk<
    any,
    GetClientPresenceLocationsFacebookTokenResponseOpts,
    {
      rejectValue: BadRequestException | UnauthorizedException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * FacebookLocation Token Connect Response
     * INIT (above) will redirect to this API and will provide the token for the connected Facebook account
     * (at this point in time the Facebook page is not connected to rC)
     */
    'getClientPresenceLocationsFacebookTokenResponse',
    async (queryParams: GetClientPresenceLocationsFacebookTokenResponseOpts, { rejectWithValue } = {} as any) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsFacebookTokenResponseAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsFacebookTokenResponse(queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsFacebookTokenResponseAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsFacebookTokenResponseAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsFacebookTokenResponseUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/facebook/token/response',
  );
  static getClientPresenceLocationsFacebookTokenResponseUrlMockRequest =
    '/app/api/client/presence/locations/facebook/token/response(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Provide the list of Facebook pages associated to the connected Facebook account
   * (only if permission is set the pages will be available)
   *
   *
   *
   * |null
   */

  /**
   * FacebookLocation Pages Request
   * Provide the list of Facebook pages associated to the connected Facebook account
   * (only if permission is set the pages will be available)
   *
   *
   *
   * |null
   */
  getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<FacebookLocationsGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/facebook/token/availableLocations`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdThunk = createAsyncThunk<
    FacebookLocationsGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * FacebookLocation Pages Request
     * Provide the list of Facebook pages associated to the connected Facebook account
     * (only if permission is set the pages will be available)
     *
     *
     *
     * |null
     */
    'getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/facebook/token/availableLocations',
  );
  static getClientPresenceLocationsFacebookTokenAvailableLocationsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook/token/availableLocations(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Connect to Facebook Location (page)
   */

  /**
   * Select Facebook Location
   * Connect to Facebook Location (page)
   */
  postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationId(
    facebookLocationId: string,
    locationId: number,
    requestBody: null,
    queryParams: PostClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<FacebookLocationSelectResponseDto> {
    return this.post(
      new EndPoint(
        `/app/api/client/presence/locations/${locationId}/facebook/token/selectFacebookLocation/${facebookLocationId}`,
      ),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdThunk =
    createAsyncThunk<
      FacebookLocationSelectResponseDto,
      {
        facebookLocationId: string;
        locationId: number;
        requestBody: null;
        queryParams: PostClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdOpts;
        contentType?: 'application/json';
      },
      {
        rejectValue:
          | BadRequestException
          | UnauthorizedException
          | NotFoundException
          | MethodNotAllowedException
          | InternalErrorException;
      }
    >(
      /**
       * Select Facebook Location
       * Connect to Facebook Location (page)
       */
      'postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationId',
      async (
        {
          facebookLocationId,
          locationId,
          requestBody,
          queryParams,
          contentType = 'application/json',
        }: {
          facebookLocationId: string;
          locationId: number;
          requestBody: null;
          queryParams: PostClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdOpts;
          contentType?: 'application/json';
        },
        { rejectWithValue } = {} as any,
      ) => {
        // Generate a random request Id
        const requestId = new Date().getTime().toString();

        try {
          // Create a new Abort controller for the request
          const controller = new AbortController();

          const signal = controller.signal;
          this.postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdAbortManager._push(
            requestId,
            controller,
          );

          const result = await firstValueFrom(
            presenceStore.postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationId(
              facebookLocationId,
              locationId,
              requestBody,
              queryParams,
              signal,
              contentType,
            ),
          );

          // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
          this.postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdAbortManager._remove(
            requestId,
          );

          return result;
        } catch (err) {
          // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
          this.postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdAbortManager._remove(
            requestId,
          );

          return rejectWithValue(err.response.data);
        }
      },
    );

  static postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdUrlRegEx =
    new RegExp(
      '/app/api/client/presence/locations/{locationId}/facebook/token/selectFacebookLocation/{facebookLocationId}',
    );
  static postClientPresenceLocationsFacebookTokenSelectFacebookLocationByFacebookLocationIdByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook/token/selectFacebookLocation/{facebookLocationId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsFacebookTokenDisconnectByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Disconnect FacebookLocation (page)
   */

  /**
   * Disconnect Facebook Location
   * Disconnect FacebookLocation (page)
   */
  postClientPresenceLocationsFacebookTokenDisconnectByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: PostClientPresenceLocationsFacebookTokenDisconnectByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<FacebookLocationDisconnectResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/facebook/token/disconnect`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsFacebookTokenDisconnectByLocationIdThunk = createAsyncThunk<
    FacebookLocationDisconnectResponseDto,
    {
      locationId: number;
      requestBody: null;
      queryParams: PostClientPresenceLocationsFacebookTokenDisconnectByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * Disconnect Facebook Location
     * Disconnect FacebookLocation (page)
     */
    'postClientPresenceLocationsFacebookTokenDisconnectByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: null;
        queryParams: PostClientPresenceLocationsFacebookTokenDisconnectByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsFacebookTokenDisconnectByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsFacebookTokenDisconnectByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsFacebookTokenDisconnectByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsFacebookTokenDisconnectByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsFacebookTokenDisconnectByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/facebook/token/disconnect',
  );
  static postClientPresenceLocationsFacebookTokenDisconnectByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/facebook/token/disconnect(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns Google location (Google Business Profile) including business profile relevant information e.g.
   * Can be configured to load additional informataion on top, e.g.
   * - statistics (performance reports on the location)
   * - attributes
   * - mediaItems
   */

  /**
   * GoogleLocation Details
   * Returns Google location (Google Business Profile) including business profile relevant information e.g.
   * Can be configured to load additional informataion on top, e.g.
   * - statistics (performance reports on the location)
   * - attributes
   * - mediaItems
   */
  getClientPresenceLocationsGoogleByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsGoogleByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleLocationGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/google`), queryParams, signal);
  }

  static getClientPresenceLocationsGoogleByLocationIdThunk = createAsyncThunk<
    GoogleLocationGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsGoogleByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Details
     * Returns Google location (Google Business Profile) including business profile relevant information e.g.
     * Can be configured to load additional informataion on top, e.g.
     * - statistics (performance reports on the location)
     * - attributes
     * - mediaItems
     */
    'getClientPresenceLocationsGoogleByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsGoogleByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsGoogleByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsGoogleByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsGoogleByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google',
  );
  static getClientPresenceLocationsGoogleByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientPresenceLocationsGoogleByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Deletes the GoogleLocation if the GoogleLocation is in pending verification, suspended or duplicate state
   * If paramter forceDeletion is passed, deletion is performed anyway
   */

  /**
   * GoogleLocation delete
   * Deletes the GoogleLocation if the GoogleLocation is in pending verification, suspended or duplicate state
   * If paramter forceDeletion is passed, deletion is performed anyway
   */
  deleteClientPresenceLocationsGoogleByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: DeleteClientPresenceLocationsGoogleByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleLocationUpdateResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientPresenceLocationsGoogleByLocationIdThunk = createAsyncThunk<
    GoogleLocationUpdateResponseDto,
    { locationId: number; requestBody: null; queryParams: DeleteClientPresenceLocationsGoogleByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation delete
     * Deletes the GoogleLocation if the GoogleLocation is in pending verification, suspended or duplicate state
     * If paramter forceDeletion is passed, deletion is performed anyway
     */
    'deleteClientPresenceLocationsGoogleByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: { locationId: number; requestBody: null; queryParams: DeleteClientPresenceLocationsGoogleByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientPresenceLocationsGoogleByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.deleteClientPresenceLocationsGoogleByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsGoogleByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsGoogleByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientPresenceLocationsGoogleByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google',
  );
  static deleteClientPresenceLocationsGoogleByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsGoogleAttributesByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates GoogleLocation Attributes
   */

  /**
   * GoogleLocation Update Attributes
   * Updates GoogleLocation Attributes
   */
  patchClientPresenceLocationsGoogleAttributesByLocationId(
    locationId: number,
    requestBody: GoogleAttributesPatchRequestDto,
    queryParams: PatchClientPresenceLocationsGoogleAttributesByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleAttributesPatchResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/attributes`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsGoogleAttributesByLocationIdThunk = createAsyncThunk<
    GoogleAttributesPatchResponseDto,
    {
      locationId: number;
      requestBody: GoogleAttributesPatchRequestDto;
      queryParams: PatchClientPresenceLocationsGoogleAttributesByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Update Attributes
     * Updates GoogleLocation Attributes
     */
    'patchClientPresenceLocationsGoogleAttributesByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: GoogleAttributesPatchRequestDto;
        queryParams: PatchClientPresenceLocationsGoogleAttributesByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsGoogleAttributesByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsGoogleAttributesByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsGoogleAttributesByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsGoogleAttributesByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsGoogleAttributesByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/attributes',
  );
  static patchClientPresenceLocationsGoogleAttributesByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/attributes(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsGoogleAttributesByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates GoogleLocation Attributes
   */

  /**
   * GoogleLocation Update Attributes
   * Updates GoogleLocation Attributes
   */
  postClientPresenceLocationsGoogleAttributesByLocationId(
    locationId: number,
    requestBody: GoogleAttributesPatchRequestDto,
    queryParams: PostClientPresenceLocationsGoogleAttributesByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<GoogleAttributesPatchResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/attributes`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsGoogleAttributesByLocationIdThunk = createAsyncThunk<
    GoogleAttributesPatchResponseDto,
    {
      locationId: number;
      requestBody: GoogleAttributesPatchRequestDto;
      queryParams: PostClientPresenceLocationsGoogleAttributesByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Update Attributes
     * Updates GoogleLocation Attributes
     */
    'postClientPresenceLocationsGoogleAttributesByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: GoogleAttributesPatchRequestDto;
        queryParams: PostClientPresenceLocationsGoogleAttributesByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsGoogleAttributesByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsGoogleAttributesByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleAttributesByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleAttributesByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsGoogleAttributesByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/attributes',
  );
  static postClientPresenceLocationsGoogleAttributesByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/attributes(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsGoogleServicesByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates Google Location Services
   */

  /**
   * GoogleLocation Update Services
   * Updates Google Location Services
   */
  patchClientPresenceLocationsGoogleServicesByLocationId(
    locationId: number,
    requestBody: GoogleServiceItemsPatchRequestDto,
    queryParams: PatchClientPresenceLocationsGoogleServicesByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleServiceItemsPatchResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/services`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsGoogleServicesByLocationIdThunk = createAsyncThunk<
    GoogleServiceItemsPatchResponseDto,
    {
      locationId: number;
      requestBody: GoogleServiceItemsPatchRequestDto;
      queryParams: PatchClientPresenceLocationsGoogleServicesByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Update Services
     * Updates Google Location Services
     */
    'patchClientPresenceLocationsGoogleServicesByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: GoogleServiceItemsPatchRequestDto;
        queryParams: PatchClientPresenceLocationsGoogleServicesByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsGoogleServicesByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsGoogleServicesByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsGoogleServicesByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsGoogleServicesByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsGoogleServicesByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/services',
  );
  static patchClientPresenceLocationsGoogleServicesByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/services(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsGoogleServicesByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates Google Location Services
   */

  /**
   * GoogleLocation Update Services
   * Updates Google Location Services
   */
  postClientPresenceLocationsGoogleServicesByLocationId(
    locationId: number,
    requestBody: GoogleServiceItemsPatchRequestDto,
    queryParams: PostClientPresenceLocationsGoogleServicesByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<GoogleServiceItemsPatchResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/services`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsGoogleServicesByLocationIdThunk = createAsyncThunk<
    GoogleServiceItemsPatchResponseDto,
    {
      locationId: number;
      requestBody: GoogleServiceItemsPatchRequestDto;
      queryParams: PostClientPresenceLocationsGoogleServicesByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Update Services
     * Updates Google Location Services
     */
    'postClientPresenceLocationsGoogleServicesByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: GoogleServiceItemsPatchRequestDto;
        queryParams: PostClientPresenceLocationsGoogleServicesByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsGoogleServicesByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsGoogleServicesByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleServicesByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleServicesByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsGoogleServicesByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/services',
  );
  static postClientPresenceLocationsGoogleServicesByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/services(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsGoogleUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates GoogleLocation Business Data, data will be taken from Location
   */

  /**
   * GoogleLocation Update business data
   * Updates GoogleLocation Business Data, data will be taken from Location
   */
  patchClientPresenceLocationsGoogleUpdateByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: PatchClientPresenceLocationsGoogleUpdateByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleLocationUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/update`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsGoogleUpdateByLocationIdThunk = createAsyncThunk<
    GoogleLocationUpdateResponseDto,
    { locationId: number; requestBody: null; queryParams: PatchClientPresenceLocationsGoogleUpdateByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Update business data
     * Updates GoogleLocation Business Data, data will be taken from Location
     */
    'patchClientPresenceLocationsGoogleUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: null;
        queryParams: PatchClientPresenceLocationsGoogleUpdateByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsGoogleUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsGoogleUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsGoogleUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsGoogleUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsGoogleUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/update',
  );
  static patchClientPresenceLocationsGoogleUpdateByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsGoogleUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates GoogleLocation Business Data, data will be taken from Location
   */

  /**
   * GoogleLocation Update business data
   * Updates GoogleLocation Business Data, data will be taken from Location
   */
  postClientPresenceLocationsGoogleUpdateByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: PostClientPresenceLocationsGoogleUpdateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<GoogleLocationUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/update`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsGoogleUpdateByLocationIdThunk = createAsyncThunk<
    GoogleLocationUpdateResponseDto,
    {
      locationId: number;
      requestBody: null;
      queryParams: PostClientPresenceLocationsGoogleUpdateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Update business data
     * Updates GoogleLocation Business Data, data will be taken from Location
     */
    'postClientPresenceLocationsGoogleUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: null;
        queryParams: PostClientPresenceLocationsGoogleUpdateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsGoogleUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsGoogleUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsGoogleUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/update',
  );
  static postClientPresenceLocationsGoogleUpdateByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsGoogleAdminsInviteByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Invites GoogleLocationAdmin by email
   */

  /**
   * GoogleLocation Admin invite
   * Invites GoogleLocationAdmin by email
   */
  postClientPresenceLocationsGoogleAdminsInviteByLocationId(
    locationId: number,
    requestBody: GoogleLocationAdminPostRequestDto,
    queryParams: PostClientPresenceLocationsGoogleAdminsInviteByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<GoogleLocationAdminPostResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/admins/invite`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsGoogleAdminsInviteByLocationIdThunk = createAsyncThunk<
    GoogleLocationAdminPostResponseDto,
    {
      locationId: number;
      requestBody: GoogleLocationAdminPostRequestDto;
      queryParams: PostClientPresenceLocationsGoogleAdminsInviteByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Admin invite
     * Invites GoogleLocationAdmin by email
     */
    'postClientPresenceLocationsGoogleAdminsInviteByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: GoogleLocationAdminPostRequestDto;
        queryParams: PostClientPresenceLocationsGoogleAdminsInviteByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsGoogleAdminsInviteByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsGoogleAdminsInviteByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleAdminsInviteByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleAdminsInviteByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsGoogleAdminsInviteByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/admins/invite',
  );
  static postClientPresenceLocationsGoogleAdminsInviteByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/admins/invite(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleVerificationsCreateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Initiates Verification of GoogleLocation
   */

  /**
   * GoogleLocation create Verification
   * Initiates Verification of GoogleLocation
   */
  getClientPresenceLocationsGoogleVerificationsCreateByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsGoogleVerificationsCreateByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleLocationVerificationResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/verifications/create`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsGoogleVerificationsCreateByLocationIdThunk = createAsyncThunk<
    GoogleLocationVerificationResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsGoogleVerificationsCreateByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation create Verification
     * Initiates Verification of GoogleLocation
     */
    'getClientPresenceLocationsGoogleVerificationsCreateByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsGoogleVerificationsCreateByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsGoogleVerificationsCreateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsGoogleVerificationsCreateByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleVerificationsCreateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleVerificationsCreateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsGoogleVerificationsCreateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/verifications/create',
  );
  static getClientPresenceLocationsGoogleVerificationsCreateByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/verifications/create(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleVerificationsCompleteByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Completes Verification of GoogleLocation by entering pincode
   */

  /**
   * GoogleLocation complete Verification
   * Completes Verification of GoogleLocation by entering pincode
   */
  getClientPresenceLocationsGoogleVerificationsCompleteByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsGoogleVerificationsCompleteByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleLocationVerificationResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/verifications/complete`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsGoogleVerificationsCompleteByLocationIdThunk = createAsyncThunk<
    GoogleLocationVerificationResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsGoogleVerificationsCompleteByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation complete Verification
     * Completes Verification of GoogleLocation by entering pincode
     */
    'getClientPresenceLocationsGoogleVerificationsCompleteByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsGoogleVerificationsCompleteByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsGoogleVerificationsCompleteByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsGoogleVerificationsCompleteByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleVerificationsCompleteByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleVerificationsCompleteByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsGoogleVerificationsCompleteByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/verifications/complete',
  );
  static getClientPresenceLocationsGoogleVerificationsCompleteByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/verifications/complete(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsGoogleSyncSettingsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Google Location Connection Sync Settings
   */

  /**
   * Update FacebookLocation Sync Settings
   * Update Google Location Connection Sync Settings
   */
  patchClientPresenceLocationsGoogleSyncSettingsByLocationId(
    locationId: number,
    requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto,
    queryParams: PatchClientPresenceLocationsGoogleSyncSettingsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationListingServiceConnectionSyncSettingsUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/syncSettings`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsGoogleSyncSettingsByLocationIdThunk = createAsyncThunk<
    LocationListingServiceConnectionSyncSettingsUpdateResponseDto,
    {
      locationId: number;
      requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto;
      queryParams: PatchClientPresenceLocationsGoogleSyncSettingsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | MethodNotAllowedException;
    }
  >(
    /**
     * Update FacebookLocation Sync Settings
     * Update Google Location Connection Sync Settings
     */
    'patchClientPresenceLocationsGoogleSyncSettingsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto;
        queryParams: PatchClientPresenceLocationsGoogleSyncSettingsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsGoogleSyncSettingsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsGoogleSyncSettingsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsGoogleSyncSettingsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsGoogleSyncSettingsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsGoogleSyncSettingsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/syncSettings',
  );
  static patchClientPresenceLocationsGoogleSyncSettingsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/syncSettings(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsGoogleSyncSettingsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Google Location Connection Sync Settings
   */

  /**
   * Update FacebookLocation Sync Settings
   * Update Google Location Connection Sync Settings
   */
  postClientPresenceLocationsGoogleSyncSettingsByLocationId(
    locationId: number,
    requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto,
    queryParams: PostClientPresenceLocationsGoogleSyncSettingsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<LocationListingServiceConnectionSyncSettingsUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/syncSettings`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsGoogleSyncSettingsByLocationIdThunk = createAsyncThunk<
    LocationListingServiceConnectionSyncSettingsUpdateResponseDto,
    {
      locationId: number;
      requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto;
      queryParams: PostClientPresenceLocationsGoogleSyncSettingsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | MethodNotAllowedException;
    }
  >(
    /**
     * Update FacebookLocation Sync Settings
     * Update Google Location Connection Sync Settings
     */
    'postClientPresenceLocationsGoogleSyncSettingsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: LocationListingServiceConnectionSyncSettingsUpdateRequestDto;
        queryParams: PostClientPresenceLocationsGoogleSyncSettingsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsGoogleSyncSettingsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsGoogleSyncSettingsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleSyncSettingsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsGoogleSyncSettingsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsGoogleSyncSettingsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/syncSettings',
  );
  static postClientPresenceLocationsGoogleSyncSettingsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/syncSettings(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleTokenInitByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Initiates token connect flow
   */

  /**
   * GoogleLocation Token Connect Init
   * Initiates token connect flow
   */
  getClientPresenceLocationsGoogleTokenInitByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsGoogleTokenInitByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<any> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/token/init`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsGoogleTokenInitByLocationIdThunk = createAsyncThunk<
    any,
    { locationId: number; queryParams: GetClientPresenceLocationsGoogleTokenInitByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Token Connect Init
     * Initiates token connect flow
     */
    'getClientPresenceLocationsGoogleTokenInitByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsGoogleTokenInitByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsGoogleTokenInitByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsGoogleTokenInitByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleTokenInitByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleTokenInitByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsGoogleTokenInitByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/token/init',
  );
  static getClientPresenceLocationsGoogleTokenInitByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/token/init(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleTokenResponseAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Handles token response, saves token and retrieves GoogleAccountProfile
   */

  /**
   * GoogleLocation Token Connect Response
   * Handles token response, saves token and retrieves GoogleAccountProfile
   */
  getClientPresenceLocationsGoogleTokenResponse(
    queryParams: GetClientPresenceLocationsGoogleTokenResponseOpts,
    signal?: AbortSignal,
  ): Observable<any> {
    return this.get(new EndPoint('/app/api/client/presence/locations/google/token/response'), queryParams, signal);
  }

  static getClientPresenceLocationsGoogleTokenResponseThunk = createAsyncThunk<
    any,
    GetClientPresenceLocationsGoogleTokenResponseOpts,
    {
      rejectValue:
        | BadRequestException
        | UnauthorizedException
        | ForbiddenException
        | NotFoundException
        | MethodNotAllowedException
        | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Token Connect Response
     * Handles token response, saves token and retrieves GoogleAccountProfile
     */
    'getClientPresenceLocationsGoogleTokenResponse',
    async (queryParams: GetClientPresenceLocationsGoogleTokenResponseOpts, { rejectWithValue } = {} as any) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsGoogleTokenResponseAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsGoogleTokenResponse(queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleTokenResponseAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleTokenResponseAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsGoogleTokenResponseUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/google/token/response',
  );
  static getClientPresenceLocationsGoogleTokenResponseUrlMockRequest =
    '/app/api/client/presence/locations/google/token/response(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns available GoogleLocations for token connections, usually in order to allow selection of GoogleLocation after granting token access
   * Applies by default a search radius of 1000 m around the customer's Location (ONLY if other filters are not applied)
   */

  /**
   * List available GoogleLocations
   * Returns available GoogleLocations for token connections, usually in order to allow selection of GoogleLocation after granting token access
   * Applies by default a search radius of 1000 m around the customer's Location (ONLY if other filters are not applied)
   */
  getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleLocationsGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/token/availableLocations`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdThunk = createAsyncThunk<
    GoogleLocationsGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * List available GoogleLocations
     * Returns available GoogleLocations for token connections, usually in order to allow selection of GoogleLocation after granting token access
     * Applies by default a search radius of 1000 m around the customer's Location (ONLY if other filters are not applied)
     */
    'getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/token/availableLocations',
  );
  static getClientPresenceLocationsGoogleTokenAvailableLocationsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/token/availableLocations(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns GooglePlaces that match Locations company name within a radius of 1000m
   */

  /**
   * List available GoogleLocations
   * Returns GooglePlaces that match Locations company name within a radius of 1000m
   */
  getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GooglePlacesSearchGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/matchingPlacesLocations`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdThunk = createAsyncThunk<
    GooglePlacesSearchGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * List available GoogleLocations
     * Returns GooglePlaces that match Locations company name within a radius of 1000m
     */
    'getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/matchingPlacesLocations',
  );
  static getClientPresenceLocationsGoogleMatchingPlacesLocationsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/matchingPlacesLocations(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Select GoogleLocation from the GoogleLocations available for current token connection.
   * Stores connection on LocationListingService and returns updated LocationListingService
   */

  /**
   * Select token-managed GoogleLocation
   * Select GoogleLocation from the GoogleLocations available for current token connection.
   * Stores connection on LocationListingService and returns updated LocationListingService
   */
  getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationId(
    googleBusinessProfileId: string,
    locationId: number,
    queryParams: GetClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleTokenSelectLocationResponseDto> {
    return this.get(
      new EndPoint(
        `/app/api/client/presence/locations/${locationId}/google/token/selectGoogleLocation/${googleBusinessProfileId}`,
      ),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdThunk =
    createAsyncThunk<
      GoogleTokenSelectLocationResponseDto,
      {
        googleBusinessProfileId: string;
        locationId: number;
        queryParams: GetClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdOpts;
      },
      {
        rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
      }
    >(
      /**
       * Select token-managed GoogleLocation
       * Select GoogleLocation from the GoogleLocations available for current token connection.
       * Stores connection on LocationListingService and returns updated LocationListingService
       */
      'getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationId',
      async (
        {
          googleBusinessProfileId,
          locationId,
          queryParams,
        }: {
          googleBusinessProfileId: string;
          locationId: number;
          queryParams: GetClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdOpts;
        },
        { rejectWithValue } = {} as any,
      ) => {
        // Generate a random request Id
        const requestId = new Date().getTime().toString();

        try {
          // Create a new Abort controller for the request
          const controller = new AbortController();

          const signal = controller.signal;
          this.getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdAbortManager._push(
            requestId,
            controller,
          );

          const result = await firstValueFrom(
            presenceStore.getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationId(
              googleBusinessProfileId,
              locationId,
              queryParams,
              signal,
            ),
          );

          // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
          this.getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdAbortManager._remove(
            requestId,
          );

          return result;
        } catch (err) {
          // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
          this.getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdAbortManager._remove(
            requestId,
          );

          return rejectWithValue(err.response.data);
        }
      },
    );

  static getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdUrlRegEx =
    new RegExp(
      '/app/api/client/presence/locations/{locationId}/google/token/selectGoogleLocation/{googleBusinessProfileId}',
    );
  static getClientPresenceLocationsGoogleTokenSelectGoogleLocationByGoogleBusinessProfileIdByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/token/selectGoogleLocation/{googleBusinessProfileId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsGoogleTokenDisconnectByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Disconnects GoogleLocation Token
   */

  /**
   * GoogleLocation Token Disconnect
   * Disconnects GoogleLocation Token
   */
  getClientPresenceLocationsGoogleTokenDisconnectByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsGoogleTokenDisconnectByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<GoogleTokenSelectLocationResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/google/token/disconnect`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsGoogleTokenDisconnectByLocationIdThunk = createAsyncThunk<
    GoogleTokenSelectLocationResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsGoogleTokenDisconnectByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * GoogleLocation Token Disconnect
     * Disconnects GoogleLocation Token
     */
    'getClientPresenceLocationsGoogleTokenDisconnectByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsGoogleTokenDisconnectByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsGoogleTokenDisconnectByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsGoogleTokenDisconnectByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleTokenDisconnectByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsGoogleTokenDisconnectByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsGoogleTokenDisconnectByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/google/token/disconnect',
  );
  static getClientPresenceLocationsGoogleTokenDisconnectByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/google/token/disconnect(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceGooglePlacesAutocompleteAbortManager: AbortControllersManager = new AbortControllersManager();
  /**
   * Returns autocomplete results for Google Places
   */

  /**
   * Google Places autocomplete
   * Returns autocomplete results for Google Places
   */
  getClientPresenceGooglePlacesAutocomplete(
    queryParams: GetClientPresenceGooglePlacesAutocompleteOpts,
    signal?: AbortSignal,
  ): Observable<GooglePlacesAutocompleteGetResponseDto> {
    return this.get(new EndPoint('/app/api/client/presence/googlePlaces/autocomplete'), queryParams, signal);
  }

  static getClientPresenceGooglePlacesAutocompleteThunk = createAsyncThunk<
    GooglePlacesAutocompleteGetResponseDto,
    GetClientPresenceGooglePlacesAutocompleteOpts,
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Google Places autocomplete
     * Returns autocomplete results for Google Places
     */
    'getClientPresenceGooglePlacesAutocomplete',
    async (queryParams: GetClientPresenceGooglePlacesAutocompleteOpts, { rejectWithValue } = {} as any) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceGooglePlacesAutocompleteAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceGooglePlacesAutocomplete(queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceGooglePlacesAutocompleteAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceGooglePlacesAutocompleteAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceGooglePlacesAutocompleteUrlRegEx = new RegExp(
    '/app/api/client/presence/googlePlaces/autocomplete',
  );
  static getClientPresenceGooglePlacesAutocompleteUrlMockRequest =
    '/app/api/client/presence/googlePlaces/autocomplete(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceGooglePlacesSearchAbortManager: AbortControllersManager = new AbortControllersManager();
  /**
   * Searches for Google Places
   */

  /**
   * GooglePlaces search
   * Searches for Google Places
   */
  getClientPresenceGooglePlacesSearch(
    queryParams: GetClientPresenceGooglePlacesSearchOpts,
    signal?: AbortSignal,
  ): Observable<GooglePlacesSearchGetResponseDto> {
    return this.get(new EndPoint('/app/api/client/presence/googlePlaces/search'), queryParams, signal);
  }

  static getClientPresenceGooglePlacesSearchThunk = createAsyncThunk<
    GooglePlacesSearchGetResponseDto,
    GetClientPresenceGooglePlacesSearchOpts,
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * GooglePlaces search
     * Searches for Google Places
     */
    'getClientPresenceGooglePlacesSearch',
    async (queryParams: GetClientPresenceGooglePlacesSearchOpts, { rejectWithValue } = {} as any) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceGooglePlacesSearchAbortManager._push(requestId, controller);

        const result = await firstValueFrom(presenceStore.getClientPresenceGooglePlacesSearch(queryParams, signal));

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceGooglePlacesSearchAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceGooglePlacesSearchAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceGooglePlacesSearchUrlRegEx = new RegExp('/app/api/client/presence/googlePlaces/search');
  static getClientPresenceGooglePlacesSearchUrlMockRequest = '/app/api/client/presence/googlePlaces/search(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceGooglePlacesByIdByGooglePlaceIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns GooglePlace Details by googlePlaceId
   *
   *
   *
   * @throws \DI\NotFoundException
   */

  /**
   * GooglePlaces Details by googlePlaceId
   * Returns GooglePlace Details by googlePlaceId
   *
   *
   *
   * @throws \DI\NotFoundException
   */
  getClientPresenceGooglePlacesByIdByGooglePlaceId(
    googlePlaceId: string,
    queryParams: GetClientPresenceGooglePlacesByIdByGooglePlaceIdOpts,
    signal?: AbortSignal,
  ): Observable<GooglePlaceDetailsGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/googlePlaces/byId/${googlePlaceId}`), queryParams, signal);
  }

  static getClientPresenceGooglePlacesByIdByGooglePlaceIdThunk = createAsyncThunk<
    GooglePlaceDetailsGetResponseDto,
    { googlePlaceId: string; queryParams: GetClientPresenceGooglePlacesByIdByGooglePlaceIdOpts },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * GooglePlaces Details by googlePlaceId
     * Returns GooglePlace Details by googlePlaceId
     *
     *
     *
     * @throws \DI\NotFoundException
     */
    'getClientPresenceGooglePlacesByIdByGooglePlaceId',
    async (
      {
        googlePlaceId,
        queryParams,
      }: { googlePlaceId: string; queryParams: GetClientPresenceGooglePlacesByIdByGooglePlaceIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceGooglePlacesByIdByGooglePlaceIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceGooglePlacesByIdByGooglePlaceId(googlePlaceId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceGooglePlacesByIdByGooglePlaceIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceGooglePlacesByIdByGooglePlaceIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceGooglePlacesByIdByGooglePlaceIdUrlRegEx = new RegExp(
    '/app/api/client/presence/googlePlaces/byId/{googlePlaceId}',
  );
  static getClientPresenceGooglePlacesByIdByGooglePlaceIdUrlMockRequest =
    '/app/api/client/presence/googlePlaces/byId/{googlePlaceId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceGooglePlacesSearchByAddressAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Searches for Google Places
   */

  /**
   * GooglePlaces search by Address
   * Searches for Google Places
   */
  getClientPresenceGooglePlacesSearchByAddress(
    queryParams: GetClientPresenceGooglePlacesSearchByAddressOpts,
    signal?: AbortSignal,
  ): Observable<GooglePlacesSearchGetResponseDto> {
    return this.get(new EndPoint('/app/api/client/presence/googlePlaces/searchByAddress'), queryParams, signal);
  }

  static getClientPresenceGooglePlacesSearchByAddressThunk = createAsyncThunk<
    GooglePlacesSearchGetResponseDto,
    GetClientPresenceGooglePlacesSearchByAddressOpts,
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * GooglePlaces search by Address
     * Searches for Google Places
     */
    'getClientPresenceGooglePlacesSearchByAddress',
    async (queryParams: GetClientPresenceGooglePlacesSearchByAddressOpts, { rejectWithValue } = {} as any) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceGooglePlacesSearchByAddressAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceGooglePlacesSearchByAddress(queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceGooglePlacesSearchByAddressAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceGooglePlacesSearchByAddressAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceGooglePlacesSearchByAddressUrlRegEx = new RegExp(
    '/app/api/client/presence/googlePlaces/searchByAddress',
  );
  static getClientPresenceGooglePlacesSearchByAddressUrlMockRequest =
    '/app/api/client/presence/googlePlaces/searchByAddress(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsInterfaceDataByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates Project's AI Assistant Setting
   */

  /**
   * Interface Data Update
   * Updates Project's AI Assistant Setting
   */
  patchClientPresenceLocationsInterfaceDataByLocationId(
    locationId: number,
    requestBody: InterfaceDataSettingRequestDto,
    queryParams: PatchClientPresenceLocationsInterfaceDataByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<InterfaceDataSettingResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/interfaceData`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsInterfaceDataByLocationIdThunk = createAsyncThunk<
    InterfaceDataSettingResponseDto,
    {
      locationId: number;
      requestBody: InterfaceDataSettingRequestDto;
      queryParams: PatchClientPresenceLocationsInterfaceDataByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Interface Data Update
     * Updates Project's AI Assistant Setting
     */
    'patchClientPresenceLocationsInterfaceDataByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: InterfaceDataSettingRequestDto;
        queryParams: PatchClientPresenceLocationsInterfaceDataByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsInterfaceDataByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsInterfaceDataByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsInterfaceDataByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsInterfaceDataByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsInterfaceDataByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/interfaceData',
  );
  static patchClientPresenceLocationsInterfaceDataByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/interfaceData(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsInterfaceDataByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates Project's AI Assistant Setting
   */

  /**
   * Interface Data Update
   * Updates Project's AI Assistant Setting
   */
  postClientPresenceLocationsInterfaceDataByLocationId(
    locationId: number,
    requestBody: InterfaceDataSettingRequestDto,
    queryParams: PostClientPresenceLocationsInterfaceDataByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<InterfaceDataSettingResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/interfaceData`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsInterfaceDataByLocationIdThunk = createAsyncThunk<
    InterfaceDataSettingResponseDto,
    {
      locationId: number;
      requestBody: InterfaceDataSettingRequestDto;
      queryParams: PostClientPresenceLocationsInterfaceDataByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Interface Data Update
     * Updates Project's AI Assistant Setting
     */
    'postClientPresenceLocationsInterfaceDataByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: InterfaceDataSettingRequestDto;
        queryParams: PostClientPresenceLocationsInterfaceDataByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsInterfaceDataByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsInterfaceDataByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsInterfaceDataByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsInterfaceDataByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsInterfaceDataByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/interfaceData',
  );
  static postClientPresenceLocationsInterfaceDataByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/interfaceData(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsListingsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns listings on directories based on defined listingServices of the requested Location
   */

  /**
   * Location Listings
   * Returns listings on directories based on defined listingServices of the requested Location
   */
  getClientPresenceLocationsListingsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsListingsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationListingsGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/listings`), queryParams, signal);
  }

  static getClientPresenceLocationsListingsByLocationIdThunk = createAsyncThunk<
    LocationListingsGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsListingsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Listings
     * Returns listings on directories based on defined listingServices of the requested Location
     */
    'getClientPresenceLocationsListingsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsListingsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsListingsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsListingsByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsListingsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsListingsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsListingsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/listings',
  );
  static getClientPresenceLocationsListingsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/listings(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsListingservicesByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns available ListingServices with Settings
   */

  /**
   * ListingServices
   * Returns available ListingServices with Settings
   */
  getClientPresenceLocationsListingservicesByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsListingservicesByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationListingServicesGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/listingservices`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsListingservicesByLocationIdThunk = createAsyncThunk<
    LocationListingServicesGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsListingservicesByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * ListingServices
     * Returns available ListingServices with Settings
     */
    'getClientPresenceLocationsListingservicesByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsListingservicesByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsListingservicesByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsListingservicesByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsListingservicesByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsListingservicesByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsListingservicesByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/listingservices',
  );
  static getClientPresenceLocationsListingservicesByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/listingservices(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsListingsUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Locations that belong to full listing services
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \Doctrine\DBAL\Exception
   */

  /**
   * Listings update
   * Update Locations that belong to full listing services
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \Doctrine\DBAL\Exception
   */
  patchClientPresenceLocationsListingsUpdateByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: PatchClientPresenceLocationsListingsUpdateByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<FullListingServiceLocationUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/listings/update`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsListingsUpdateByLocationIdThunk = createAsyncThunk<
    FullListingServiceLocationUpdateResponseDto,
    { locationId: number; requestBody: null; queryParams: PatchClientPresenceLocationsListingsUpdateByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * Listings update
     * Update Locations that belong to full listing services
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     * @throws \Doctrine\DBAL\Exception
     */
    'patchClientPresenceLocationsListingsUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: null;
        queryParams: PatchClientPresenceLocationsListingsUpdateByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsListingsUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsListingsUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsListingsUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsListingsUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsListingsUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/listings/update',
  );
  static patchClientPresenceLocationsListingsUpdateByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/listings/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsListingsUpdateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Locations that belong to full listing services
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \Doctrine\DBAL\Exception
   */

  /**
   * Listings update
   * Update Locations that belong to full listing services
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \Doctrine\DBAL\Exception
   */
  postClientPresenceLocationsListingsUpdateByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: PostClientPresenceLocationsListingsUpdateByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<FullListingServiceLocationUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/listings/update`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsListingsUpdateByLocationIdThunk = createAsyncThunk<
    FullListingServiceLocationUpdateResponseDto,
    {
      locationId: number;
      requestBody: null;
      queryParams: PostClientPresenceLocationsListingsUpdateByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * Listings update
     * Update Locations that belong to full listing services
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     * @throws \Doctrine\DBAL\Exception
     */
    'postClientPresenceLocationsListingsUpdateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: null;
        queryParams: PostClientPresenceLocationsListingsUpdateByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsListingsUpdateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsListingsUpdateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsListingsUpdateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsListingsUpdateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsListingsUpdateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/listings/update',
  );
  static postClientPresenceLocationsListingsUpdateByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/listings/update(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientPresenceLocationsListingsDeactivateByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Deactivate Locations that belong to full listing services
   */

  /**
   * Listings deactivate
   * Deactivate Locations that belong to full listing services
   */
  deleteClientPresenceLocationsListingsDeactivateByLocationId(
    locationId: number,
    requestBody: null,
    queryParams: DeleteClientPresenceLocationsListingsDeactivateByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<FullListingServiceLocationDeactivationResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/listings/deactivate`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientPresenceLocationsListingsDeactivateByLocationIdThunk = createAsyncThunk<
    FullListingServiceLocationDeactivationResponseDto,
    {
      locationId: number;
      requestBody: null;
      queryParams: DeleteClientPresenceLocationsListingsDeactivateByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * Listings deactivate
     * Deactivate Locations that belong to full listing services
     */
    'deleteClientPresenceLocationsListingsDeactivateByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: null;
        queryParams: DeleteClientPresenceLocationsListingsDeactivateByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientPresenceLocationsListingsDeactivateByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.deleteClientPresenceLocationsListingsDeactivateByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsListingsDeactivateByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsListingsDeactivateByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientPresenceLocationsListingsDeactivateByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/listings/deactivate',
  );
  static deleteClientPresenceLocationsListingsDeactivateByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/listings/deactivate(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsYextByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns the Yext Location including business profile relevant information e.g.
   * - company data
   * - contact data
   * - opening times
   * - categories
   * - description
   * - photos
   */

  /**
   * Yext Location Details
   * Returns the Yext Location including business profile relevant information e.g.
   * - company data
   * - contact data
   * - opening times
   * - categories
   * - description
   * - photos
   */
  getClientPresenceLocationsYextByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsYextByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<YextLocationGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/yext`), queryParams, signal);
  }

  static getClientPresenceLocationsYextByLocationIdThunk = createAsyncThunk<
    YextLocationGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsYextByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * Yext Location Details
     * Returns the Yext Location including business profile relevant information e.g.
     * - company data
     * - contact data
     * - opening times
     * - categories
     * - description
     * - photos
     */
    'getClientPresenceLocationsYextByLocationId',
    async (
      { locationId, queryParams }: { locationId: number; queryParams: GetClientPresenceLocationsYextByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsYextByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsYextByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsYextByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsYextByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsYextByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/yext',
  );
  static getClientPresenceLocationsYextByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/yext(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsByLocationIdAbortManager: AbortControllersManager = new AbortControllersManager();
  /**
   * Returns the Location with expandable sub entities
   */

  /**
   * Location Details
   * Returns the Location with expandable sub entities
   */
  getClientPresenceLocationsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}`), queryParams, signal);
  }

  static getClientPresenceLocationsByLocationIdThunk = createAsyncThunk<
    LocationGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Details
     * Returns the Location with expandable sub entities
     */
    'getClientPresenceLocationsByLocationId',
    async (
      { locationId, queryParams }: { locationId: number; queryParams: GetClientPresenceLocationsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsByLocationIdUrlRegEx = new RegExp('/app/api/client/presence/locations/{locationId}');
  static getClientPresenceLocationsByLocationIdUrlMockRequest = '/app/api/client/presence/locations/{locationId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsByLocationIdAbortManager: AbortControllersManager = new AbortControllersManager();
  /**
   * Updates Location Data, can be with separate information on segment, e.g. categories
   */

  /**
   * Location Update
   * Updates Location Data, can be with separate information on segment, e.g. categories
   */
  patchClientPresenceLocationsByLocationId(
    locationId: number,
    requestBody: LocationUpdateRequestDto,
    queryParams: PatchClientPresenceLocationsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationGetResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsByLocationIdThunk = createAsyncThunk<
    LocationGetResponseDto,
    {
      locationId: number;
      requestBody: LocationUpdateRequestDto;
      queryParams: PatchClientPresenceLocationsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | ForbiddenException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Update
     * Updates Location Data, can be with separate information on segment, e.g. categories
     */
    'patchClientPresenceLocationsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: LocationUpdateRequestDto;
        queryParams: PatchClientPresenceLocationsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}',
  );
  static patchClientPresenceLocationsByLocationIdUrlMockRequest = '/app/api/client/presence/locations/{locationId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsByLocationIdAbortManager: AbortControllersManager = new AbortControllersManager();
  /**
   * Updates Location Data, can be with separate information on segment, e.g. categories
   */

  /**
   * Location Update
   * Updates Location Data, can be with separate information on segment, e.g. categories
   */
  postClientPresenceLocationsByLocationId(
    locationId: number,
    requestBody: LocationUpdateRequestDto,
    queryParams: PostClientPresenceLocationsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<LocationGetResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsByLocationIdThunk = createAsyncThunk<
    LocationGetResponseDto,
    {
      locationId: number;
      requestBody: LocationUpdateRequestDto;
      queryParams: PostClientPresenceLocationsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | ForbiddenException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Update
     * Updates Location Data, can be with separate information on segment, e.g. categories
     */
    'postClientPresenceLocationsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: LocationUpdateRequestDto;
        queryParams: PostClientPresenceLocationsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}',
  );
  static postClientPresenceLocationsByLocationIdUrlMockRequest = '/app/api/client/presence/locations/{locationId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsSettingsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns Location's settings
   */

  /**
   * Location Settings
   * Returns Location's settings
   */
  getClientPresenceLocationsSettingsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsSettingsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationSettingsGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/settings`), queryParams, signal);
  }

  static getClientPresenceLocationsSettingsByLocationIdThunk = createAsyncThunk<
    LocationSettingsGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsSettingsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Settings
     * Returns Location's settings
     */
    'getClientPresenceLocationsSettingsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsSettingsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsSettingsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsSettingsByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsSettingsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsSettingsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsSettingsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/settings',
  );
  static getClientPresenceLocationsSettingsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/settings(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsSummaryByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns location with multiple subentities preloaded:
   * - company
   * - address
   * - reputation.businessRating
   * - mediaItems
   * - categories
   */

  /**
   * Location Summary
   * Returns location with multiple subentities preloaded:
   * - company
   * - address
   * - reputation.businessRating
   * - mediaItems
   * - categories
   */
  getClientPresenceLocationsSummaryByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsSummaryByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/summary`), queryParams, signal);
  }

  static getClientPresenceLocationsSummaryByLocationIdThunk = createAsyncThunk<
    LocationGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsSummaryByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Summary
     * Returns location with multiple subentities preloaded:
     * - company
     * - address
     * - reputation.businessRating
     * - mediaItems
     * - categories
     */
    'getClientPresenceLocationsSummaryByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsSummaryByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsSummaryByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsSummaryByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsSummaryByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsSummaryByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsSummaryByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/summary',
  );
  static getClientPresenceLocationsSummaryByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/summary(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsCompanyVerificationByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns Location Company Identification Details
   */

  /**
   * Company Verification Get
   * Returns Location Company Identification Details
   */
  getClientPresenceLocationsCompanyVerificationByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsCompanyVerificationByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationCompanyCompanyVerificationResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsCompanyVerificationByLocationIdThunk = createAsyncThunk<
    LocationCompanyCompanyVerificationResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsCompanyVerificationByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Company Verification Get
     * Returns Location Company Identification Details
     */
    'getClientPresenceLocationsCompanyVerificationByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsCompanyVerificationByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsCompanyVerificationByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsCompanyVerificationByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification',
  );
  static getClientPresenceLocationsCompanyVerificationByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsCompanyVerificationByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates Location Company Identification Details
   */

  /**
   * Company Verification Update
   * Updates Location Company Identification Details
   */
  patchClientPresenceLocationsCompanyVerificationByLocationId(
    locationId: number,
    requestBody: LocationCompanyCompanyVerificationUpdateRequestDto,
    queryParams: PatchClientPresenceLocationsCompanyVerificationByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationCompanyCompanyVerificationResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsCompanyVerificationByLocationIdThunk = createAsyncThunk<
    LocationCompanyCompanyVerificationResponseDto,
    {
      locationId: number;
      requestBody: LocationCompanyCompanyVerificationUpdateRequestDto;
      queryParams: PatchClientPresenceLocationsCompanyVerificationByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | ForbiddenException | InternalErrorException;
    }
  >(
    /**
     * Company Verification Update
     * Updates Location Company Identification Details
     */
    'patchClientPresenceLocationsCompanyVerificationByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: LocationCompanyCompanyVerificationUpdateRequestDto;
        queryParams: PatchClientPresenceLocationsCompanyVerificationByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsCompanyVerificationByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsCompanyVerificationByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification',
  );
  static patchClientPresenceLocationsCompanyVerificationByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsCompanyVerificationByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates Location Company Identification Details
   */

  /**
   * Company Verification Update
   * Updates Location Company Identification Details
   */
  postClientPresenceLocationsCompanyVerificationByLocationId(
    locationId: number,
    requestBody: LocationCompanyCompanyVerificationUpdateRequestDto,
    queryParams: PostClientPresenceLocationsCompanyVerificationByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<LocationCompanyCompanyVerificationResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsCompanyVerificationByLocationIdThunk = createAsyncThunk<
    LocationCompanyCompanyVerificationResponseDto,
    {
      locationId: number;
      requestBody: LocationCompanyCompanyVerificationUpdateRequestDto;
      queryParams: PostClientPresenceLocationsCompanyVerificationByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | ForbiddenException | InternalErrorException;
    }
  >(
    /**
     * Company Verification Update
     * Updates Location Company Identification Details
     */
    'postClientPresenceLocationsCompanyVerificationByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: LocationCompanyCompanyVerificationUpdateRequestDto;
        queryParams: PostClientPresenceLocationsCompanyVerificationByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsCompanyVerificationByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCompanyVerificationByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsCompanyVerificationByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification',
  );
  static postClientPresenceLocationsCompanyVerificationByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsLocalesByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns a list with the locales for the Location
   */

  /**
   * Get Locales for the Location
   * Returns a list with the locales for the Location
   */
  getClientPresenceLocationsLocalesByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsLocalesByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationLocalesGetResponseDTO> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/locales`), queryParams, signal);
  }

  static getClientPresenceLocationsLocalesByLocationIdThunk = createAsyncThunk<
    LocationLocalesGetResponseDTO,
    { locationId: number; queryParams: GetClientPresenceLocationsLocalesByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Get Locales for the Location
     * Returns a list with the locales for the Location
     */
    'getClientPresenceLocationsLocalesByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsLocalesByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsLocalesByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsLocalesByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsLocalesByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsLocalesByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsLocalesByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/locales',
  );
  static getClientPresenceLocationsLocalesByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/locales(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsResetTasksByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Deletes the Location's tasks and resets Task reassignment flags
   */

  /**
   * Location Tasks reset
   * Deletes the Location's tasks and resets Task reassignment flags
   */
  getClientPresenceLocationsResetTasksByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsResetTasksByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/resetTasks`), queryParams, signal);
  }

  static getClientPresenceLocationsResetTasksByLocationIdThunk = createAsyncThunk<
    LocationGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsResetTasksByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Tasks reset
     * Deletes the Location's tasks and resets Task reassignment flags
     */
    'getClientPresenceLocationsResetTasksByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsResetTasksByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsResetTasksByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsResetTasksByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsResetTasksByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsResetTasksByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsResetTasksByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/resetTasks',
  );
  static getClientPresenceLocationsResetTasksByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/resetTasks(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns non-null if ServiceAreas exist outside the Location's country
   */

  /**
   * Location ServiceAreas outside Country
   * Returns non-null if ServiceAreas exist outside the Location's country
   */
  postClientPresenceLocationsServiceAreasNotMatchCountryByLocationId(
    locationId: number,
    requestBody: LocationServiceAreasNotMatchCountryRequestDto,
    queryParams: PostClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<ServiceAreasNotMatchCountryResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/serviceAreas/notMatchCountry`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdThunk = createAsyncThunk<
    ServiceAreasNotMatchCountryResponseDto,
    {
      locationId: number;
      requestBody: LocationServiceAreasNotMatchCountryRequestDto;
      queryParams: PostClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location ServiceAreas outside Country
     * Returns non-null if ServiceAreas exist outside the Location's country
     */
    'postClientPresenceLocationsServiceAreasNotMatchCountryByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: LocationServiceAreasNotMatchCountryRequestDto;
        queryParams: PostClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsServiceAreasNotMatchCountryByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/serviceAreas/notMatchCountry',
  );
  static postClientPresenceLocationsServiceAreasNotMatchCountryByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/serviceAreas/notMatchCountry(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsIsFreeAccountByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns whether the associated account is a free account or not
   */

  /**
   * Weather the Account is free or not
   * Returns whether the associated account is a free account or not
   */
  getClientPresenceLocationsIsFreeAccountByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsIsFreeAccountByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationFreeUserGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/isFreeAccount`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsIsFreeAccountByLocationIdThunk = createAsyncThunk<
    LocationFreeUserGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsIsFreeAccountByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Weather the Account is free or not
     * Returns whether the associated account is a free account or not
     */
    'getClientPresenceLocationsIsFreeAccountByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsIsFreeAccountByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsIsFreeAccountByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsIsFreeAccountByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsIsFreeAccountByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsIsFreeAccountByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsIsFreeAccountByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/isFreeAccount',
  );
  static getClientPresenceLocationsIsFreeAccountByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/isFreeAccount(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsMediaItemsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns location media items
   */

  /**
   * Location Media Items
   * Returns location media items
   */
  getClientPresenceLocationsMediaItemsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsMediaItemsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationMediaItemsGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/mediaItems`), queryParams, signal);
  }

  static getClientPresenceLocationsMediaItemsByLocationIdThunk = createAsyncThunk<
    LocationMediaItemsGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsMediaItemsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Media Items
     * Returns location media items
     */
    'getClientPresenceLocationsMediaItemsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsMediaItemsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsMediaItemsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsMediaItemsByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsMediaItemsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsMediaItemsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsMediaItemsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/mediaItems',
  );
  static getClientPresenceLocationsMediaItemsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientPresenceLocationsMediaItemsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Deletes location media items
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \JsonException
   */

  /**
   * Location Media Items Delete
   * Deletes location media items
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \JsonException
   */
  deleteClientPresenceLocationsMediaItemsByLocationId(
    locationId: number,
    requestBody: LocationMediaItemsPatchRequestDto,
    queryParams: DeleteClientPresenceLocationsMediaItemsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationMediaItemsPostResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/mediaItems`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientPresenceLocationsMediaItemsByLocationIdThunk = createAsyncThunk<
    LocationMediaItemsPostResponseDto,
    {
      locationId: number;
      requestBody: LocationMediaItemsPatchRequestDto;
      queryParams: DeleteClientPresenceLocationsMediaItemsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Media Items Delete
     * Deletes location media items
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     * @throws \JsonException
     */
    'deleteClientPresenceLocationsMediaItemsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: LocationMediaItemsPatchRequestDto;
        queryParams: DeleteClientPresenceLocationsMediaItemsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientPresenceLocationsMediaItemsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.deleteClientPresenceLocationsMediaItemsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsMediaItemsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsMediaItemsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientPresenceLocationsMediaItemsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/mediaItems',
  );
  static deleteClientPresenceLocationsMediaItemsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsMediaItemsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates location media items
   */

  /**
   * Location Media Items Update
   * Updates location media items
   */
  patchClientPresenceLocationsMediaItemsByLocationId(
    locationId: number,
    requestBody: LocationMediaItemsPatchRequestDto,
    queryParams: PatchClientPresenceLocationsMediaItemsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationMediaItemsPostResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/mediaItems`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsMediaItemsByLocationIdThunk = createAsyncThunk<
    LocationMediaItemsPostResponseDto,
    {
      locationId: number;
      requestBody: LocationMediaItemsPatchRequestDto;
      queryParams: PatchClientPresenceLocationsMediaItemsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Media Items Update
     * Updates location media items
     */
    'patchClientPresenceLocationsMediaItemsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: LocationMediaItemsPatchRequestDto;
        queryParams: PatchClientPresenceLocationsMediaItemsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsMediaItemsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsMediaItemsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsMediaItemsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsMediaItemsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsMediaItemsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/mediaItems',
  );
  static patchClientPresenceLocationsMediaItemsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsMediaItemsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Updates location media items
   */

  /**
   * Location Media Items Update
   * Updates location media items
   */
  postClientPresenceLocationsMediaItemsByLocationId(
    locationId: number,
    requestBody: LocationMediaItemsPatchRequestDto,
    queryParams: PostClientPresenceLocationsMediaItemsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<LocationMediaItemsPostResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/mediaItems`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsMediaItemsByLocationIdThunk = createAsyncThunk<
    LocationMediaItemsPostResponseDto,
    {
      locationId: number;
      requestBody: LocationMediaItemsPatchRequestDto;
      queryParams: PostClientPresenceLocationsMediaItemsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Media Items Update
     * Updates location media items
     */
    'postClientPresenceLocationsMediaItemsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: LocationMediaItemsPatchRequestDto;
        queryParams: PostClientPresenceLocationsMediaItemsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsMediaItemsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsMediaItemsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsMediaItemsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsMediaItemsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsMediaItemsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/mediaItems',
  );
  static postClientPresenceLocationsMediaItemsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsVisibilityByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns the Local Visibility Index for a location for the whole date range.
   * If few data points are availble, date series are on a daily basis, otherwise one data point per week is returned.
   */

  /**
   * Local Visbility Index
   * Returns the Local Visibility Index for a location for the whole date range.
   * If few data points are availble, date series are on a daily basis, otherwise one data point per week is returned.
   */
  getClientPresenceLocationsVisibilityByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsVisibilityByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<LocationVisibilityIndexGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/visibility`), queryParams, signal);
  }

  static getClientPresenceLocationsVisibilityByLocationIdThunk = createAsyncThunk<
    LocationVisibilityIndexGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsVisibilityByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | MethodNotAllowedException | InternalErrorException;
    }
  >(
    /**
     * Local Visbility Index
     * Returns the Local Visibility Index for a location for the whole date range.
     * If few data points are availble, date series are on a daily basis, otherwise one data point per week is returned.
     */
    'getClientPresenceLocationsVisibilityByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsVisibilityByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsVisibilityByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsVisibilityByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsVisibilityByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsVisibilityByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsVisibilityByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/visibility',
  );
  static getClientPresenceLocationsVisibilityByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/visibility(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceMediaItemsLocationByJwtAbortManager: AbortControllersManager = new AbortControllersManager();
  /**
   * Returns location mediaItem image
   */

  /**
   * Location Media Items
   * Returns location mediaItem image
   */
  getClientPresenceMediaItemsLocationByJwt(
    jwt: string,
    queryParams: GetClientPresenceMediaItemsLocationByJwtOpts,
    signal?: AbortSignal,
  ): Observable<any> {
    return this.get(new EndPoint(`/app/api/client/presence/mediaItems/location/${jwt}`), queryParams, signal);
  }

  static getClientPresenceMediaItemsLocationByJwtThunk = createAsyncThunk<
    any,
    { jwt: string; queryParams: GetClientPresenceMediaItemsLocationByJwtOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Location Media Items
     * Returns location mediaItem image
     */
    'getClientPresenceMediaItemsLocationByJwt',
    async (
      { jwt, queryParams }: { jwt: string; queryParams: GetClientPresenceMediaItemsLocationByJwtOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceMediaItemsLocationByJwtAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceMediaItemsLocationByJwt(jwt, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceMediaItemsLocationByJwtAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceMediaItemsLocationByJwtAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceMediaItemsLocationByJwtUrlRegEx = new RegExp(
    '/app/api/client/presence/mediaItems/location/{jwt}',
  );
  static getClientPresenceMediaItemsLocationByJwtUrlMockRequest =
    '/app/api/client/presence/mediaItems/location/{jwt}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceMediaItemsPostByJwtAbortManager: AbortControllersManager = new AbortControllersManager();
  /**
   * Returns post mediaItem image
   */

  /**
   * Post Media Items
   * Returns post mediaItem image
   */
  getClientPresenceMediaItemsPostByJwt(
    jwt: string,
    queryParams: GetClientPresenceMediaItemsPostByJwtOpts,
    signal?: AbortSignal,
  ): Observable<any> {
    return this.get(new EndPoint(`/app/api/client/presence/mediaItems/post/${jwt}`), queryParams, signal);
  }

  static getClientPresenceMediaItemsPostByJwtThunk = createAsyncThunk<
    any,
    { jwt: string; queryParams: GetClientPresenceMediaItemsPostByJwtOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Post Media Items
     * Returns post mediaItem image
     */
    'getClientPresenceMediaItemsPostByJwt',
    async (
      { jwt, queryParams }: { jwt: string; queryParams: GetClientPresenceMediaItemsPostByJwtOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceMediaItemsPostByJwtAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceMediaItemsPostByJwt(jwt, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceMediaItemsPostByJwtAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceMediaItemsPostByJwtAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceMediaItemsPostByJwtUrlRegEx = new RegExp('/app/api/client/presence/mediaItems/post/{jwt}');
  static getClientPresenceMediaItemsPostByJwtUrlMockRequest = '/app/api/client/presence/mediaItems/post/{jwt}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceMediaItemsVerificationByJwtAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns company verification media items
   */

  /**
   * Identification Media Items
   * Returns company verification media items
   */
  getClientPresenceMediaItemsVerificationByJwt(
    jwt: string,
    queryParams: GetClientPresenceMediaItemsVerificationByJwtOpts,
    signal?: AbortSignal,
  ): Observable<any> {
    return this.get(new EndPoint(`/app/api/client/presence/mediaItems/verification/${jwt}`), queryParams, signal);
  }

  static getClientPresenceMediaItemsVerificationByJwtThunk = createAsyncThunk<
    any,
    { jwt: string; queryParams: GetClientPresenceMediaItemsVerificationByJwtOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Identification Media Items
     * Returns company verification media items
     */
    'getClientPresenceMediaItemsVerificationByJwt',
    async (
      { jwt, queryParams }: { jwt: string; queryParams: GetClientPresenceMediaItemsVerificationByJwtOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceMediaItemsVerificationByJwtAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceMediaItemsVerificationByJwt(jwt, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceMediaItemsVerificationByJwtAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceMediaItemsVerificationByJwtAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceMediaItemsVerificationByJwtUrlRegEx = new RegExp(
    '/app/api/client/presence/mediaItems/verification/{jwt}',
  );
  static getClientPresenceMediaItemsVerificationByJwtUrlMockRequest =
    '/app/api/client/presence/mediaItems/verification/{jwt}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsPostsMediaItemsByPostIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Retrive Post Media Items
   */

  /**
   * Post Media Items List
   * Retrive Post Media Items
   */
  getClientPresenceLocationsPostsMediaItemsByPostId(
    postId: number,
    locationId: number,
    queryParams: GetClientPresenceLocationsPostsMediaItemsByPostIdOpts,
    signal?: AbortSignal,
  ): Observable<PostMediaItemsGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/${postId}/mediaItems`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsPostsMediaItemsByPostIdThunk = createAsyncThunk<
    PostMediaItemsGetResponseDto,
    { postId: number; locationId: number; queryParams: GetClientPresenceLocationsPostsMediaItemsByPostIdOpts },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * Post Media Items List
     * Retrive Post Media Items
     */
    'getClientPresenceLocationsPostsMediaItemsByPostId',
    async (
      {
        postId,
        locationId,
        queryParams,
      }: { postId: number; locationId: number; queryParams: GetClientPresenceLocationsPostsMediaItemsByPostIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsPostsMediaItemsByPostId(postId, locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsPostsMediaItemsByPostIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/{postId}/mediaItems',
  );
  static getClientPresenceLocationsPostsMediaItemsByPostIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/{postId}/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsPostsMediaItemsByPostIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Post Media Items
   */

  /**
   * Post Media Items Update
   * Update Post Media Items
   */
  patchClientPresenceLocationsPostsMediaItemsByPostId(
    postId: number,
    locationId: number,
    requestBody: PostMediaItemsPatchRequestDto,
    queryParams: PatchClientPresenceLocationsPostsMediaItemsByPostIdOpts,
    signal?: AbortSignal,
  ): Observable<PostMediaItemsPatchResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/${postId}/mediaItems`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsPostsMediaItemsByPostIdThunk = createAsyncThunk<
    PostMediaItemsPatchResponseDto,
    {
      postId: number;
      locationId: number;
      requestBody: PostMediaItemsPatchRequestDto;
      queryParams: PatchClientPresenceLocationsPostsMediaItemsByPostIdOpts;
    },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * Post Media Items Update
     * Update Post Media Items
     */
    'patchClientPresenceLocationsPostsMediaItemsByPostId',
    async (
      {
        postId,
        locationId,
        requestBody,
        queryParams,
      }: {
        postId: number;
        locationId: number;
        requestBody: PostMediaItemsPatchRequestDto;
        queryParams: PatchClientPresenceLocationsPostsMediaItemsByPostIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsPostsMediaItemsByPostId(
            postId,
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsPostsMediaItemsByPostIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/{postId}/mediaItems',
  );
  static patchClientPresenceLocationsPostsMediaItemsByPostIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/{postId}/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsPostsMediaItemsByPostIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Post Media Items
   */

  /**
   * Post Media Items Update
   * Update Post Media Items
   */
  postClientPresenceLocationsPostsMediaItemsByPostId(
    postId: number,
    locationId: number,
    requestBody: PostMediaItemsPatchRequestDto,
    queryParams: PostClientPresenceLocationsPostsMediaItemsByPostIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<PostMediaItemsPatchResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/${postId}/mediaItems`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsPostsMediaItemsByPostIdThunk = createAsyncThunk<
    PostMediaItemsPatchResponseDto,
    {
      postId: number;
      locationId: number;
      requestBody: PostMediaItemsPatchRequestDto;
      queryParams: PostClientPresenceLocationsPostsMediaItemsByPostIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * Post Media Items Update
     * Update Post Media Items
     */
    'postClientPresenceLocationsPostsMediaItemsByPostId',
    async (
      {
        postId,
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        postId: number;
        locationId: number;
        requestBody: PostMediaItemsPatchRequestDto;
        queryParams: PostClientPresenceLocationsPostsMediaItemsByPostIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsPostsMediaItemsByPostId(
            postId,
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsMediaItemsByPostIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsPostsMediaItemsByPostIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/{postId}/mediaItems',
  );
  static postClientPresenceLocationsPostsMediaItemsByPostIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/{postId}/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsPostsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Retrieve Location Posts|Events
   */

  /**
   * Posts|Events List
   * Retrieve Location Posts|Events
   */
  getClientPresenceLocationsPostsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsPostsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostsGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/posts`), queryParams, signal);
  }

  static getClientPresenceLocationsPostsByLocationIdThunk = createAsyncThunk<
    PostsGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsPostsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Posts|Events List
     * Retrieve Location Posts|Events
     */
    'getClientPresenceLocationsPostsByLocationId',
    async (
      { locationId, queryParams }: { locationId: number; queryParams: GetClientPresenceLocationsPostsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsPostsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsPostsByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsPostsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts',
  );
  static getClientPresenceLocationsPostsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsPostsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update or create Post|Event locally
   */

  /**
   * Post|Event Update
   * Update or create Post|Event locally
   */
  patchClientPresenceLocationsPostsByLocationId(
    locationId: number,
    requestBody: PostUpdateRequestDto,
    queryParams: PatchClientPresenceLocationsPostsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsPostsByLocationIdThunk = createAsyncThunk<
    PostUpdateResponseDto,
    {
      locationId: number;
      requestBody: PostUpdateRequestDto;
      queryParams: PatchClientPresenceLocationsPostsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | InternalErrorException;
    }
  >(
    /**
     * Post|Event Update
     * Update or create Post|Event locally
     */
    'patchClientPresenceLocationsPostsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: PostUpdateRequestDto;
        queryParams: PatchClientPresenceLocationsPostsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsPostsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsPostsByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsPostsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts',
  );
  static patchClientPresenceLocationsPostsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsPostsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update or create Post|Event locally
   */

  /**
   * Post|Event Update
   * Update or create Post|Event locally
   */
  postClientPresenceLocationsPostsByLocationId(
    locationId: number,
    requestBody: PostUpdateRequestDto,
    queryParams: PostClientPresenceLocationsPostsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<PostUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsPostsByLocationIdThunk = createAsyncThunk<
    PostUpdateResponseDto,
    {
      locationId: number;
      requestBody: PostUpdateRequestDto;
      queryParams: PostClientPresenceLocationsPostsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | InternalErrorException;
    }
  >(
    /**
     * Post|Event Update
     * Update or create Post|Event locally
     */
    'postClientPresenceLocationsPostsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: PostUpdateRequestDto;
        queryParams: PostClientPresenceLocationsPostsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsPostsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsPostsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsPostsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts',
  );
  static postClientPresenceLocationsPostsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsPostsByPostIdByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get Location Posts|Events by id
   */

  /**
   * Post|Event Details
   * Get Location Posts|Events by id
   */
  getClientPresenceLocationsPostsByPostIdByLocationId(
    postId: number,
    locationId: number,
    queryParams: GetClientPresenceLocationsPostsByPostIdByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostUpdateResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/${postId}`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsPostsByPostIdByLocationIdThunk = createAsyncThunk<
    PostUpdateResponseDto,
    { postId: number; locationId: number; queryParams: GetClientPresenceLocationsPostsByPostIdByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Post|Event Details
     * Get Location Posts|Events by id
     */
    'getClientPresenceLocationsPostsByPostIdByLocationId',
    async (
      {
        postId,
        locationId,
        queryParams,
      }: { postId: number; locationId: number; queryParams: GetClientPresenceLocationsPostsByPostIdByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsPostsByPostIdByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsPostsByPostIdByLocationId(postId, locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsByPostIdByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsByPostIdByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsPostsByPostIdByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/{postId}',
  );
  static getClientPresenceLocationsPostsByPostIdByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/{postId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientPresenceLocationsPostsByPostIdByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Delete Post|Event from ListingServices and DB
   */

  /**
   * Post|Event Delete
   * Delete Post|Event from ListingServices and DB
   */
  deleteClientPresenceLocationsPostsByPostIdByLocationId(
    postId: number,
    locationId: number,
    requestBody: null,
    queryParams: DeleteClientPresenceLocationsPostsByPostIdByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostDeleteResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/${postId}`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientPresenceLocationsPostsByPostIdByLocationIdThunk = createAsyncThunk<
    PostDeleteResponseDto,
    {
      postId: number;
      locationId: number;
      requestBody: null;
      queryParams: DeleteClientPresenceLocationsPostsByPostIdByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Post|Event Delete
     * Delete Post|Event from ListingServices and DB
     */
    'deleteClientPresenceLocationsPostsByPostIdByLocationId',
    async (
      {
        postId,
        locationId,
        requestBody,
        queryParams,
      }: {
        postId: number;
        locationId: number;
        requestBody: null;
        queryParams: DeleteClientPresenceLocationsPostsByPostIdByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientPresenceLocationsPostsByPostIdByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.deleteClientPresenceLocationsPostsByPostIdByLocationId(
            postId,
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsPostsByPostIdByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsPostsByPostIdByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientPresenceLocationsPostsByPostIdByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/{postId}',
  );
  static deleteClientPresenceLocationsPostsByPostIdByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/{postId}(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsPostsCommentsByPostIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get the Comments attached to a Post|Event
   */

  /**
   * Post|Event Comments
   * Get the Comments attached to a Post|Event
   */
  getClientPresenceLocationsPostsCommentsByPostId(
    postId: number,
    locationId: number,
    queryParams: GetClientPresenceLocationsPostsCommentsByPostIdOpts,
    signal?: AbortSignal,
  ): Observable<SocialMediaCommentsGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/${postId}/comments`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsPostsCommentsByPostIdThunk = createAsyncThunk<
    SocialMediaCommentsGetResponseDto,
    { postId: number; locationId: number; queryParams: GetClientPresenceLocationsPostsCommentsByPostIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Post|Event Comments
     * Get the Comments attached to a Post|Event
     */
    'getClientPresenceLocationsPostsCommentsByPostId',
    async (
      {
        postId,
        locationId,
        queryParams,
      }: { postId: number; locationId: number; queryParams: GetClientPresenceLocationsPostsCommentsByPostIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsPostsCommentsByPostIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsPostsCommentsByPostId(postId, locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsCommentsByPostIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsCommentsByPostIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsPostsCommentsByPostIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/{postId}/comments',
  );
  static getClientPresenceLocationsPostsCommentsByPostIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/{postId}/comments(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static putClientPresenceLocationsPostsPublishByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Publish Post|Event
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \Throwable
   */

  /**
   * Post|Event Publish
   * Publish Post|Event
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   *
   * @throws \Throwable
   */
  putClientPresenceLocationsPostsPublishByLocationId(
    locationId: number,
    requestBody: PostUpdateRequestDto,
    queryParams: PutClientPresenceLocationsPostsPublishByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostUpdateResponseDto> {
    return this.put(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/publish`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static putClientPresenceLocationsPostsPublishByLocationIdThunk = createAsyncThunk<
    PostUpdateResponseDto,
    {
      locationId: number;
      requestBody: PostUpdateRequestDto;
      queryParams: PutClientPresenceLocationsPostsPublishByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Post|Event Publish
     * Publish Post|Event
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     * @throws \Throwable
     */
    'putClientPresenceLocationsPostsPublishByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: PostUpdateRequestDto;
        queryParams: PutClientPresenceLocationsPostsPublishByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.putClientPresenceLocationsPostsPublishByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.putClientPresenceLocationsPostsPublishByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.putClientPresenceLocationsPostsPublishByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.putClientPresenceLocationsPostsPublishByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static putClientPresenceLocationsPostsPublishByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/publish',
  );
  static putClientPresenceLocationsPostsPublishByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/publish(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static putClientPresenceLocationsPostsEditByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Edit Post|Event on ListingServices
   */

  /**
   * Edit Post|Event on ListingServices
   * Edit Post|Event on ListingServices
   */
  putClientPresenceLocationsPostsEditByLocationId(
    locationId: number,
    requestBody: PostEditRequestDto,
    queryParams: PutClientPresenceLocationsPostsEditByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostEditResponseDto> {
    return this.put(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/edit`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static putClientPresenceLocationsPostsEditByLocationIdThunk = createAsyncThunk<
    PostEditResponseDto,
    {
      locationId: number;
      requestBody: PostEditRequestDto;
      queryParams: PutClientPresenceLocationsPostsEditByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException;
    }
  >(
    /**
     * Edit Post|Event on ListingServices
     * Edit Post|Event on ListingServices
     */
    'putClientPresenceLocationsPostsEditByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: PostEditRequestDto;
        queryParams: PutClientPresenceLocationsPostsEditByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.putClientPresenceLocationsPostsEditByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.putClientPresenceLocationsPostsEditByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.putClientPresenceLocationsPostsEditByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.putClientPresenceLocationsPostsEditByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static putClientPresenceLocationsPostsEditByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/edit',
  );
  static putClientPresenceLocationsPostsEditByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/edit(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsPostsGenerateInstructionByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Generates Post based on user instruction
   */

  /**
   * Post Generate with instruction
   * Generates Post based on user instruction
   */
  patchClientPresenceLocationsPostsGenerateInstructionByLocationId(
    locationId: number,
    requestBody: PostInstructionGenerateRequestDto,
    queryParams: PatchClientPresenceLocationsPostsGenerateInstructionByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/generate/instruction`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsPostsGenerateInstructionByLocationIdThunk = createAsyncThunk<
    PostUpdateResponseDto,
    {
      locationId: number;
      requestBody: PostInstructionGenerateRequestDto;
      queryParams: PatchClientPresenceLocationsPostsGenerateInstructionByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Post Generate with instruction
     * Generates Post based on user instruction
     */
    'patchClientPresenceLocationsPostsGenerateInstructionByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: PostInstructionGenerateRequestDto;
        queryParams: PatchClientPresenceLocationsPostsGenerateInstructionByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsPostsGenerateInstructionByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsPostsGenerateInstructionByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsGenerateInstructionByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsGenerateInstructionByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsPostsGenerateInstructionByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/generate/instruction',
  );
  static patchClientPresenceLocationsPostsGenerateInstructionByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/generate/instruction(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsPostsGenerateInstructionByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Generates Post based on user instruction
   */

  /**
   * Post Generate with instruction
   * Generates Post based on user instruction
   */
  postClientPresenceLocationsPostsGenerateInstructionByLocationId(
    locationId: number,
    requestBody: PostInstructionGenerateRequestDto,
    queryParams: PostClientPresenceLocationsPostsGenerateInstructionByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<PostUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/generate/instruction`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsPostsGenerateInstructionByLocationIdThunk = createAsyncThunk<
    PostUpdateResponseDto,
    {
      locationId: number;
      requestBody: PostInstructionGenerateRequestDto;
      queryParams: PostClientPresenceLocationsPostsGenerateInstructionByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Post Generate with instruction
     * Generates Post based on user instruction
     */
    'postClientPresenceLocationsPostsGenerateInstructionByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: PostInstructionGenerateRequestDto;
        queryParams: PostClientPresenceLocationsPostsGenerateInstructionByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsPostsGenerateInstructionByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsPostsGenerateInstructionByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsGenerateInstructionByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsGenerateInstructionByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsPostsGenerateInstructionByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/generate/instruction',
  );
  static postClientPresenceLocationsPostsGenerateInstructionByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/generate/instruction(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsPostsCompetitorsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get Competitors' Posts for Location
   */

  /**
   * Competitors Posts List
   * Get Competitors' Posts for Location
   */
  getClientPresenceLocationsPostsCompetitorsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsPostsCompetitorsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostsCompetitorsGetResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/competitors`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsPostsCompetitorsByLocationIdThunk = createAsyncThunk<
    PostsCompetitorsGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsPostsCompetitorsByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Competitors Posts List
     * Get Competitors' Posts for Location
     */
    'getClientPresenceLocationsPostsCompetitorsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsPostsCompetitorsByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsPostsCompetitorsByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsPostsCompetitorsByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsCompetitorsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsPostsCompetitorsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsPostsCompetitorsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/competitors',
  );
  static getClientPresenceLocationsPostsCompetitorsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/competitors(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Generate Posts Variants based on Competitors Posts
   */

  /**
   * Posts Generate using Competitors Posts
   * Generate Posts Variants based on Competitors Posts
   */
  patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationId(
    locationId: number,
    requestBody: PostsCompetitorsGenerateRequestDto,
    queryParams: PatchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostsGetResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/generate/competitorsPosts`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdThunk = createAsyncThunk<
    PostsGetResponseDto,
    {
      locationId: number;
      requestBody: PostsCompetitorsGenerateRequestDto;
      queryParams: PatchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Posts Generate using Competitors Posts
     * Generate Posts Variants based on Competitors Posts
     */
    'patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: PostsCompetitorsGenerateRequestDto;
        queryParams: PatchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/generate/competitorsPosts',
  );
  static patchClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/generate/competitorsPosts(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Generate Posts Variants based on Competitors Posts
   */

  /**
   * Posts Generate using Competitors Posts
   * Generate Posts Variants based on Competitors Posts
   */
  postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationId(
    locationId: number,
    requestBody: PostsCompetitorsGenerateRequestDto,
    queryParams: PostClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<PostsGetResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/generate/competitorsPosts`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdThunk = createAsyncThunk<
    PostsGetResponseDto,
    {
      locationId: number;
      requestBody: PostsCompetitorsGenerateRequestDto;
      queryParams: PostClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Posts Generate using Competitors Posts
     * Generate Posts Variants based on Competitors Posts
     */
    'postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: PostsCompetitorsGenerateRequestDto;
        queryParams: PostClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/generate/competitorsPosts',
  );
  static postClientPresenceLocationsPostsGenerateCompetitorsPostsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/generate/competitorsPosts(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Generates Event based on user instruction
   */

  /**
   * Generate Event by Instruction
   * Generates Event based on user instruction
   */
  patchClientPresenceLocationsPostsGenerateEventInstructionByLocationId(
    locationId: number,
    requestBody: EventInstructionGenerateRequestDto,
    queryParams: PatchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<PostUpdateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/generateEvent/instruction`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdThunk = createAsyncThunk<
    PostUpdateResponseDto,
    {
      locationId: number;
      requestBody: EventInstructionGenerateRequestDto;
      queryParams: PatchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Generate Event by Instruction
     * Generates Event based on user instruction
     */
    'patchClientPresenceLocationsPostsGenerateEventInstructionByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: EventInstructionGenerateRequestDto;
        queryParams: PatchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsPostsGenerateEventInstructionByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/generateEvent/instruction',
  );
  static patchClientPresenceLocationsPostsGenerateEventInstructionByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/generateEvent/instruction(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsPostsGenerateEventInstructionByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Generates Event based on user instruction
   */

  /**
   * Generate Event by Instruction
   * Generates Event based on user instruction
   */
  postClientPresenceLocationsPostsGenerateEventInstructionByLocationId(
    locationId: number,
    requestBody: EventInstructionGenerateRequestDto,
    queryParams: PostClientPresenceLocationsPostsGenerateEventInstructionByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<PostUpdateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/posts/generateEvent/instruction`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsPostsGenerateEventInstructionByLocationIdThunk = createAsyncThunk<
    PostUpdateResponseDto,
    {
      locationId: number;
      requestBody: EventInstructionGenerateRequestDto;
      queryParams: PostClientPresenceLocationsPostsGenerateEventInstructionByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Generate Event by Instruction
     * Generates Event based on user instruction
     */
    'postClientPresenceLocationsPostsGenerateEventInstructionByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: EventInstructionGenerateRequestDto;
        queryParams: PostClientPresenceLocationsPostsGenerateEventInstructionByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsPostsGenerateEventInstructionByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsPostsGenerateEventInstructionByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsGenerateEventInstructionByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsPostsGenerateEventInstructionByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsPostsGenerateEventInstructionByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/posts/generateEvent/instruction',
  );
  static postClientPresenceLocationsPostsGenerateEventInstructionByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/posts/generateEvent/instruction(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsCommentByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get Social Media Comment by externalId (externalId is the id of the comment in the social media platform)
   */

  /**
   * Get a comment
   * Get Social Media Comment by externalId (externalId is the id of the comment in the social media platform)
   */
  getClientPresenceLocationsCommentByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsCommentByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<SocialMediaCommentGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/comment`), queryParams, signal);
  }

  static getClientPresenceLocationsCommentByLocationIdThunk = createAsyncThunk<
    SocialMediaCommentGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsCommentByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Get a comment
     * Get Social Media Comment by externalId (externalId is the id of the comment in the social media platform)
     */
    'getClientPresenceLocationsCommentByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsCommentByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsCommentByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsCommentByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCommentByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCommentByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsCommentByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/comment',
  );
  static getClientPresenceLocationsCommentByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/comment(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsCommentByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Editing a social media comment
   */

  /**
   * Edit a comment
   * Editing a social media comment
   */
  postClientPresenceLocationsCommentByLocationId(
    locationId: number,
    requestBody: SocialMediaCommentPostRequestDto,
    queryParams: PostClientPresenceLocationsCommentByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<SocialMediaCommentPostResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/comment`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsCommentByLocationIdThunk = createAsyncThunk<
    SocialMediaCommentPostResponseDto,
    {
      locationId: number;
      requestBody: SocialMediaCommentPostRequestDto;
      queryParams: PostClientPresenceLocationsCommentByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException;
    }
  >(
    /**
     * Edit a comment
     * Editing a social media comment
     */
    'postClientPresenceLocationsCommentByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: SocialMediaCommentPostRequestDto;
        queryParams: PostClientPresenceLocationsCommentByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsCommentByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsCommentByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCommentByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCommentByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsCommentByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/comment',
  );
  static postClientPresenceLocationsCommentByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/comment(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsCommentByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Editing a social media comment
   */

  /**
   * Edit a comment
   * Editing a social media comment
   */
  patchClientPresenceLocationsCommentByLocationId(
    locationId: number,
    requestBody: SocialMediaCommentPostRequestDto,
    queryParams: PatchClientPresenceLocationsCommentByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<SocialMediaCommentPostResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/comment`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsCommentByLocationIdThunk = createAsyncThunk<
    SocialMediaCommentPostResponseDto,
    {
      locationId: number;
      requestBody: SocialMediaCommentPostRequestDto;
      queryParams: PatchClientPresenceLocationsCommentByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException;
    }
  >(
    /**
     * Edit a comment
     * Editing a social media comment
     */
    'patchClientPresenceLocationsCommentByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: SocialMediaCommentPostRequestDto;
        queryParams: PatchClientPresenceLocationsCommentByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsCommentByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsCommentByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCommentByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCommentByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsCommentByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/comment',
  );
  static patchClientPresenceLocationsCommentByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/comment(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientPresenceLocationsCommentByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Delete a social media comment dor reply
   */

  /**
   * Delete a comment
   * Delete a social media comment dor reply
   */
  deleteClientPresenceLocationsCommentByLocationId(
    locationId: number,
    requestBody: SocialMediaCommentPostRequestDto,
    queryParams: DeleteClientPresenceLocationsCommentByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<SocialMediaCommentDeleteResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/comment`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientPresenceLocationsCommentByLocationIdThunk = createAsyncThunk<
    SocialMediaCommentDeleteResponseDto,
    {
      locationId: number;
      requestBody: SocialMediaCommentPostRequestDto;
      queryParams: DeleteClientPresenceLocationsCommentByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | ForbiddenException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Delete a comment
     * Delete a social media comment dor reply
     */
    'deleteClientPresenceLocationsCommentByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: SocialMediaCommentPostRequestDto;
        queryParams: DeleteClientPresenceLocationsCommentByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientPresenceLocationsCommentByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.deleteClientPresenceLocationsCommentByLocationId(locationId, requestBody, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsCommentByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsCommentByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientPresenceLocationsCommentByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/comment',
  );
  static deleteClientPresenceLocationsCommentByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/comment(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsCommentReactionByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Adds a Reaction to a comment - Like
   */

  /**
   * Like a comment
   * Adds a Reaction to a comment - Like
   */
  postClientPresenceLocationsCommentReactionByLocationId(
    locationId: number,
    requestBody: SocialMediaCommentPostRequestDto,
    queryParams: PostClientPresenceLocationsCommentReactionByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<SocialMediaCommentDeleteResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/comment/reaction`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsCommentReactionByLocationIdThunk = createAsyncThunk<
    SocialMediaCommentDeleteResponseDto,
    {
      locationId: number;
      requestBody: SocialMediaCommentPostRequestDto;
      queryParams: PostClientPresenceLocationsCommentReactionByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException;
    }
  >(
    /**
     * Like a comment
     * Adds a Reaction to a comment - Like
     */
    'postClientPresenceLocationsCommentReactionByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: SocialMediaCommentPostRequestDto;
        queryParams: PostClientPresenceLocationsCommentReactionByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsCommentReactionByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsCommentReactionByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCommentReactionByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCommentReactionByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsCommentReactionByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/comment/reaction',
  );
  static postClientPresenceLocationsCommentReactionByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/comment/reaction(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static deleteClientPresenceLocationsCommentReactionByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Deletes a comment's reaction - like
   */

  /**
   * Delete a like
   * Deletes a comment's reaction - like
   */
  deleteClientPresenceLocationsCommentReactionByLocationId(
    locationId: number,
    requestBody: SocialMediaCommentPostRequestDto,
    queryParams: DeleteClientPresenceLocationsCommentReactionByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<SocialMediaCommentDeleteResponseDto> {
    return this.delete(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/comment/reaction`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static deleteClientPresenceLocationsCommentReactionByLocationIdThunk = createAsyncThunk<
    SocialMediaCommentDeleteResponseDto,
    {
      locationId: number;
      requestBody: SocialMediaCommentPostRequestDto;
      queryParams: DeleteClientPresenceLocationsCommentReactionByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException;
    }
  >(
    /**
     * Delete a like
     * Deletes a comment's reaction - like
     */
    'deleteClientPresenceLocationsCommentReactionByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: SocialMediaCommentPostRequestDto;
        queryParams: DeleteClientPresenceLocationsCommentReactionByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.deleteClientPresenceLocationsCommentReactionByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.deleteClientPresenceLocationsCommentReactionByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsCommentReactionByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.deleteClientPresenceLocationsCommentReactionByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static deleteClientPresenceLocationsCommentReactionByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/comment/reaction',
  );
  static deleteClientPresenceLocationsCommentReactionByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/comment/reaction(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsCommentAiReplyByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Generates a Comment Reply with AI
   */

  /**
   * Generate Comment Reply with AI
   * Generates a Comment Reply with AI
   */
  patchClientPresenceLocationsCommentAiReplyByLocationId(
    locationId: number,
    requestBody: SocialMediaCommentReplyAIGenerateRequestDto,
    queryParams: PatchClientPresenceLocationsCommentAiReplyByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<SocialMediaCommentReplyAIGenerateResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/comment/ai/reply`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsCommentAiReplyByLocationIdThunk = createAsyncThunk<
    SocialMediaCommentReplyAIGenerateResponseDto,
    {
      locationId: number;
      requestBody: SocialMediaCommentReplyAIGenerateRequestDto;
      queryParams: PatchClientPresenceLocationsCommentAiReplyByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Generate Comment Reply with AI
     * Generates a Comment Reply with AI
     */
    'patchClientPresenceLocationsCommentAiReplyByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: SocialMediaCommentReplyAIGenerateRequestDto;
        queryParams: PatchClientPresenceLocationsCommentAiReplyByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsCommentAiReplyByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsCommentAiReplyByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCommentAiReplyByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCommentAiReplyByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsCommentAiReplyByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/comment/ai/reply',
  );
  static patchClientPresenceLocationsCommentAiReplyByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/comment/ai/reply(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsCommentAiReplyByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Generates a Comment Reply with AI
   */

  /**
   * Generate Comment Reply with AI
   * Generates a Comment Reply with AI
   */
  postClientPresenceLocationsCommentAiReplyByLocationId(
    locationId: number,
    requestBody: SocialMediaCommentReplyAIGenerateRequestDto,
    queryParams: PostClientPresenceLocationsCommentAiReplyByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<SocialMediaCommentReplyAIGenerateResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/comment/ai/reply`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsCommentAiReplyByLocationIdThunk = createAsyncThunk<
    SocialMediaCommentReplyAIGenerateResponseDto,
    {
      locationId: number;
      requestBody: SocialMediaCommentReplyAIGenerateRequestDto;
      queryParams: PostClientPresenceLocationsCommentAiReplyByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Generate Comment Reply with AI
     * Generates a Comment Reply with AI
     */
    'postClientPresenceLocationsCommentAiReplyByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: SocialMediaCommentReplyAIGenerateRequestDto;
        queryParams: PostClientPresenceLocationsCommentAiReplyByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsCommentAiReplyByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsCommentAiReplyByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCommentAiReplyByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCommentAiReplyByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsCommentAiReplyByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/comment/ai/reply',
  );
  static postClientPresenceLocationsCommentAiReplyByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/comment/ai/reply(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsUberallByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Returns the Uberall Location including business profile relevant information e.g.
   * - company data
   * - contact data
   * - opening times
   * - categories
   * - description
   * - photos
   */

  /**
   * Uberall Location Details
   * Returns the Uberall Location including business profile relevant information e.g.
   * - company data
   * - contact data
   * - opening times
   * - categories
   * - description
   * - photos
   */
  getClientPresenceLocationsUberallByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsUberallByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<UberallLocationGetResponseDto> {
    return this.get(new EndPoint(`/app/api/client/presence/locations/${locationId}/uberall`), queryParams, signal);
  }

  static getClientPresenceLocationsUberallByLocationIdThunk = createAsyncThunk<
    UberallLocationGetResponseDto,
    { locationId: number; queryParams: GetClientPresenceLocationsUberallByLocationIdOpts },
    {
      rejectValue: BadRequestException | NotFoundException;
    }
  >(
    /**
     * Uberall Location Details
     * Returns the Uberall Location including business profile relevant information e.g.
     * - company data
     * - contact data
     * - opening times
     * - categories
     * - description
     * - photos
     */
    'getClientPresenceLocationsUberallByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: { locationId: number; queryParams: GetClientPresenceLocationsUberallByLocationIdOpts },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsUberallByLocationIdAbortManager._push(requestId, controller);

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsUberallByLocationId(locationId, queryParams, signal),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsUberallByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsUberallByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsUberallByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/uberall',
  );
  static getClientPresenceLocationsUberallByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/uberall(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Business Verification Media Items
   */

  /**
   * Business VerificationMediaItems Update
   * Update Business Verification Media Items
   */
  patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId(
    locationId: number,
    requestBody: VerificationMediaItemsUpdateRequestDto,
    queryParams: PatchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<VerificationMediaItemsResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/business/mediaItems`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdThunk = createAsyncThunk<
    VerificationMediaItemsResponseDto,
    {
      locationId: number;
      requestBody: VerificationMediaItemsUpdateRequestDto;
      queryParams: PatchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Business VerificationMediaItems Update
     * Update Business Verification Media Items
     */
    'patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: VerificationMediaItemsUpdateRequestDto;
        queryParams: PatchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/business/mediaItems',
  );
  static patchClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/business/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Business Verification Media Items
   */

  /**
   * Business VerificationMediaItems Update
   * Update Business Verification Media Items
   */
  postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId(
    locationId: number,
    requestBody: VerificationMediaItemsUpdateRequestDto,
    queryParams: PostClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<VerificationMediaItemsResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/business/mediaItems`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdThunk = createAsyncThunk<
    VerificationMediaItemsResponseDto,
    {
      locationId: number;
      requestBody: VerificationMediaItemsUpdateRequestDto;
      queryParams: PostClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Business VerificationMediaItems Update
     * Update Business Verification Media Items
     */
    'postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: VerificationMediaItemsUpdateRequestDto;
        queryParams: PostClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/business/mediaItems',
  );
  static postClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/business/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get Business Verification Media Items
   */

  /**
   * Business VerificationMediaItems
   * Get Business Verification Media Items
   */
  getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<VerificationMediaItemsResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/business/mediaItems`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdThunk = createAsyncThunk<
    VerificationMediaItemsResponseDto,
    {
      locationId: number;
      queryParams: GetClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Business VerificationMediaItems
     * Get Business Verification Media Items
     */
    'getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: {
        locationId: number;
        queryParams: GetClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._remove(requestId);

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdAbortManager._remove(requestId);

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/business/mediaItems',
  );
  static getClientPresenceLocationsCompanyVerificationBusinessMediaItemsByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/business/mediaItems(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Owner Additional VerificationMediaItems
   */

  /**
   * Owner Additional VerificationMediaItems Update
   * Update Owner Additional VerificationMediaItems
   */
  patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId(
    locationId: number,
    requestBody: VerificationMediaItemsUpdateRequestDto,
    queryParams: PatchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<VerificationMediaItemsResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/owner/mediaItems/additional`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdThunk = createAsyncThunk<
    VerificationMediaItemsResponseDto,
    {
      locationId: number;
      requestBody: VerificationMediaItemsUpdateRequestDto;
      queryParams: PatchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Owner Additional VerificationMediaItems Update
     * Update Owner Additional VerificationMediaItems
     */
    'patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: VerificationMediaItemsUpdateRequestDto;
        queryParams: PatchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/additional',
  );
  static patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/additional(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Owner Additional VerificationMediaItems
   */

  /**
   * Owner Additional VerificationMediaItems Update
   * Update Owner Additional VerificationMediaItems
   */
  postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId(
    locationId: number,
    requestBody: VerificationMediaItemsUpdateRequestDto,
    queryParams: PostClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<VerificationMediaItemsResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/owner/mediaItems/additional`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdThunk = createAsyncThunk<
    VerificationMediaItemsResponseDto,
    {
      locationId: number;
      requestBody: VerificationMediaItemsUpdateRequestDto;
      queryParams: PostClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Owner Additional VerificationMediaItems Update
     * Update Owner Additional VerificationMediaItems
     */
    'postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: VerificationMediaItemsUpdateRequestDto;
        queryParams: PostClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/additional',
  );
  static postClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/additional(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get Owner Additional VerificationMediaItems
   */

  /**
   * Owner Additional VerificationMediaItems
   * Get Owner Additional VerificationMediaItems
   */
  getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<VerificationMediaItemsResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/owner/mediaItems/additional`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdThunk = createAsyncThunk<
    VerificationMediaItemsResponseDto,
    {
      locationId: number;
      queryParams: GetClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Owner Additional VerificationMediaItems
     * Get Owner Additional VerificationMediaItems
     */
    'getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: {
        locationId: number;
        queryParams: GetClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/additional',
  );
  static getClientPresenceLocationsCompanyVerificationOwnerMediaItemsAdditionalByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/additional(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Owner Additional VerificationMediaItems
   */

  /**
   * Owner Additional VerificationMediaItems Update
   * Update Owner Additional VerificationMediaItems
   */
  patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId(
    locationId: number,
    requestBody: OwnerVerificationDocumentUpdateRequestDto,
    queryParams: PatchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<OwnerVerificationDocumentResponseDto> {
    return this.patch(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/owner/mediaItems/document`),
      requestBody,
      queryParams,
      signal,
    );
  }

  static patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdThunk = createAsyncThunk<
    OwnerVerificationDocumentResponseDto,
    {
      locationId: number;
      requestBody: OwnerVerificationDocumentUpdateRequestDto;
      queryParams: PatchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Owner Additional VerificationMediaItems Update
     * Update Owner Additional VerificationMediaItems
     */
    'patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
      }: {
        locationId: number;
        requestBody: OwnerVerificationDocumentUpdateRequestDto;
        queryParams: PatchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/document',
  );
  static patchClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/document(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Update Owner Additional VerificationMediaItems
   */

  /**
   * Owner Additional VerificationMediaItems Update
   * Update Owner Additional VerificationMediaItems
   */
  postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId(
    locationId: number,
    requestBody: OwnerVerificationDocumentUpdateRequestDto,
    queryParams: PostClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts,
    signal?: AbortSignal,
    contentType?: 'application/json',
  ): Observable<OwnerVerificationDocumentResponseDto> {
    return this.post(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/owner/mediaItems/document`),
      requestBody,
      queryParams,
      signal,
      contentType,
    );
  }

  static postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdThunk = createAsyncThunk<
    OwnerVerificationDocumentResponseDto,
    {
      locationId: number;
      requestBody: OwnerVerificationDocumentUpdateRequestDto;
      queryParams: PostClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts;
      contentType?: 'application/json';
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Owner Additional VerificationMediaItems Update
     * Update Owner Additional VerificationMediaItems
     */
    'postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId',
    async (
      {
        locationId,
        requestBody,
        queryParams,
        contentType = 'application/json',
      }: {
        locationId: number;
        requestBody: OwnerVerificationDocumentUpdateRequestDto;
        queryParams: PostClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts;
        contentType?: 'application/json';
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId(
            locationId,
            requestBody,
            queryParams,
            signal,
            contentType,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/document',
  );
  static postClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/document(.*)';

  /**
   * Manager of list of AbortControllers for the Request
   */
  static getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager: AbortControllersManager =
    new AbortControllersManager();
  /**
   * Get Owner Additional VerificationMediaItems
   */

  /**
   * Owner Additional VerificationMediaItems
   * Get Owner Additional VerificationMediaItems
   */
  getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId(
    locationId: number,
    queryParams: GetClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts,
    signal?: AbortSignal,
  ): Observable<OwnerVerificationDocumentResponseDto> {
    return this.get(
      new EndPoint(`/app/api/client/presence/locations/${locationId}/company/verification/owner/mediaItems/document`),
      queryParams,
      signal,
    );
  }

  static getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdThunk = createAsyncThunk<
    OwnerVerificationDocumentResponseDto,
    {
      locationId: number;
      queryParams: GetClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts;
    },
    {
      rejectValue: BadRequestException | NotFoundException | InternalErrorException;
    }
  >(
    /**
     * Owner Additional VerificationMediaItems
     * Get Owner Additional VerificationMediaItems
     */
    'getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId',
    async (
      {
        locationId,
        queryParams,
      }: {
        locationId: number;
        queryParams: GetClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdOpts;
      },
      { rejectWithValue } = {} as any,
    ) => {
      // Generate a random request Id
      const requestId = new Date().getTime().toString();

      try {
        // Create a new Abort controller for the request
        const controller = new AbortController();

        const signal = controller.signal;
        this.getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._push(
          requestId,
          controller,
        );

        const result = await firstValueFrom(
          presenceStore.getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationId(
            locationId,
            queryParams,
            signal,
          ),
        );

        // After the Request is completed, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._remove(
          requestId,
        );

        return result;
      } catch (err) {
        // In case the Request fails, remove the Abort controler from Manager, since we don't need it anymore.
        this.getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdAbortManager._remove(
          requestId,
        );

        return rejectWithValue(err.response.data);
      }
    },
  );

  static getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdUrlRegEx = new RegExp(
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/document',
  );
  static getClientPresenceLocationsCompanyVerificationOwnerMediaItemsDocumentByLocationIdUrlMockRequest =
    '/app/api/client/presence/locations/{locationId}/company/verification/owner/mediaItems/document(.*)';
}
export const presenceStore = new PresenceStore();
